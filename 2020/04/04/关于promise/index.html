<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="归来半生，仍是少年"><meta name="keywords" content="atidat,生活随笔,技术积累"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.5"><title>关于promise | 春花秋月何时了</title><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">关于promise</h1><a id="logo" href="/.">春花秋月何时了</a><p class="description">一切皆对象</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa undefined"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">关于promise</h1><div class="post-meta"><a href="/2020/04/04/%E5%85%B3%E4%BA%8Epromise/#comments" class="comment-count"></a><p><span class="date">Apr 04, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>归档下阮一峰《ECMAScript6》之Promise对象</p>
<h1 id="初窥Promise"><a href="#初窥Promise" class="headerlink" title="初窥Promise"></a>初窥Promise</h1><p>Promise：<br>抽象层面：可以看作为一个容器，保存着某个未来才会结束的事件（异步操作）<br>代码层面：是一个对象，从它获取异步操作的消息   </p>
<h2 id="Primose状态"><a href="#Primose状态" class="headerlink" title="Primose状态"></a>Primose状态</h2><p>1、对象的状态不受外界影响。<br>    1.1、Promise对象代表一个异步操作，始终处于以下的某一种状态：pending（进行中）、fulfilled（已成功）、rejected（已失效）<br>    1.2、只有异步操作的结果，才决定当前的状态<br>2、一旦对象状态改变，就不会再变，任何时候都可以得到这个结果。<br>    2.1、以下两种情况才会导致状态改变：pending -&gt; fulfilled 和 pending -&gt; rejected.<br>    2.2、状态凝固了，称为resolved. 此时，再对Promise对象添加回调函数，也会立即得到结果。   </p>
<h2 id="Promise缺点"><a href="#Promise缺点" class="headerlink" title="Promise缺点"></a>Promise缺点</h2><p>1、无法取消Promise. 新建后立刻执行，无法取消<br>2、若不设置回调函数，Promise内部抛出的函数，不会反馈到外部<br>3、处于pending状态时，无法得知进展到哪一阶段（刚开始 or 结束）</p>
<h1 id="Promise基本用法"><a href="#Promise基本用法" class="headerlink" title="Promise基本用法"></a>Promise基本用法</h1><h2 id="一个Promise实例"><a href="#一个Promise实例" class="headerlink" title="一个Promise实例"></a>一个Promise实例</h2><pre><code>const promise = new Promise(function(resolve, reject) {
    // business code
    if(/*异步操作成功*/) {
        resolve(value);
    } else{
        reject(error);
    }
})</code></pre><p>1、Promise构造函数接收一个函数作为参数，该函数的参数为resolve和reject. resolve和reject时JavaScript提供的函数<br>2、resolve：将Promise对象状态从 pending -&gt; fulfilled. 异步操作成功时调用，将异步操作的结果，作为参数传递出去<br>3、reject：将Promise对象状态从 pending -&gt; rejected. 异步操作失败时调用，将异步操作抛出错误，作为参数传递出去   </p>
<h2 id="then"><a href="#then" class="headerlink" title=".then()"></a>.then()</h2><pre><code>promise.then(function(value) {
    // success
}, function(error) {
    // failure
})</code></pre><p>1、生成Promise实例后，用then方法分别指定resolved状态和reject状态的回调函数<br>2、then方法接收两个回调函数作为参数，第二个回调函数可选。第一个回调函数是Promise对象的状态变为resolved调用，第二个回调函数是Promise对象的状态变为rejected时调用。   </p>
<pre><code>function timeout(ms) {
    return new Promise(function(reslove, reject) {
        console.log(&#39;Promise&#39;);
        setTimeout(resolve, ms, &#39;done&#39;)；
    })；
}

timetout(100).then((value) =&gt; {
    console.log(value);
})</code></pre><p>上述代码，timeout方法返回一个Promise实例，表示一段时间后发生的结果。过了指定时间后，Promise实例状态变为resolved，触发then方法绑定的回调函数</p>
<pre><code>let promise = new Promise(function(resolve, reject) {
    console.log(&#39;Promise);
    resolve();
});

promise.then(funciton() {
    console.log(&#39;resolve.&#39;);
});

console.log(&#39;Hi&#39;);

// output:
//      Promise
//      Hi
//      resolve.
// 解释：Promise新建后立刻执行，首先输出Promise，而then方法指定的回调函数，将在当前脚本所有同步任务执行完才执行，故&quot;resolve&quot;最后执行</code></pre><p>异步加载图片</p>
<pre><code>function loadImageAsync(url) {
    return new Promise(function(resolve, reject) {
        const image = new Image();
        image.onload = function() {
            resolve(image);
        }

        image.onerror = function() {
            reject(new Error(&#39;could not load image&#39;));
        }
        image.src= url;        
    });
}</code></pre><p>Ajax操作</p>
<pre><code>const getJson = function(url) {
    const promise = new Promise(function(resolve, reject) {
        const handle = function() {
            if (this.readyState !=== 4) {
                return;
            }
            if (this.status === 200) {
                resolve(this.response);
            } else {
                reject(new Error(this.statusText));
            }
        };

        const client = new XMLHttpRequest();
        // do some client code
    });
    return promise;
}

getJson(&quot;/posts.json&quot;).then(function(json) {
    console.log(&#39;Contentes: &#39; + json);
}, function(error) {
    console.error(&#39;corrupted: &#39;, error)
});</code></pre><p>1、resolve和reject函数带有参数，那么它们的参数会被传递给回调函数。<br>2、reject参数通常为Error对象的实例<br>3、resolve函数除了为普通值，还可以为一个新的promise。如</p>
<pre><code>const p1 = new Promise(function(resovle, reject) {});
const p2 = new Promise(function(resovle, reject) {
    resolve(p1);
});</code></pre><p>此时，p1的状态会传递给p2. 即p1的状态决定p2的状态。若p1是pending，则p2也是pending；若p1是resolved or rejected，则p2的回调函数立刻执行。   </p>
<h2 id="深入-then"><a href="#深入-then" class="headerlink" title="深入.then()"></a>深入.then()</h2><p>1、then方法返回的是一个新的Promise实例，则可以写链式then方法。如：</p>
<pre><code>getJson(&quot;./posts.json&quot;).then(function(json) {
    return json.post;
}).then(function(post) {
    // ...
});</code></pre><p>2、箭指函数写法</p>
<pre><code>getJson(&quot;./posts.json&quot;).then(
    post =&gt; getJson(post.commentURL)
).then(
    comments =&gt; console.log(&quot;resolved: &quot;, comments),
    err =&gt; console.log(&quot;rejected: &quot;, err)
);</code></pre><h2 id="catch"><a href="#catch" class="headerlink" title=".catch()"></a>.catch()</h2><p>指定发生错误时的回调函数，是then(null, rejection) or then(undefined, rejection)的别名。</p>
<pre><code>getJson(&quot;./posts.json&quot;).then(
    posts =&gt; // ...
).catch(
    error =&gt; console.log(&#39;corrupted error&#39;, error);
);</code></pre><p>异步操作抛出错误和then方法抛出错误都会被catch方法捕获   </p>
<p>前面说过，then方法一般只写resolved状态的函数，rejected状态的函数总在catch方法使用。如：</p>
<pre><code>// bad code
promise.then(
    data =&gt; {};
    err =&gt; {};
);

// good code
promise.then(
    data =&gt; {};
).catch(
    err =&gt; {};
);</code></pre><h2 id="finally"><a href="#finally" class="headerlink" title=".finally()"></a>.finally()</h2><p>不管Promise对象状态如何，finally方法，保证其内部代码都会执行。<br>.finally()的回调函数不接受任何参数，即不依赖于Promise的执行结果。   </p>
<h2 id="all"><a href="#all" class="headerlink" title=".all()"></a>.all()</h2><p>.all()将多个Promise实例，包装成一个新的Promise实例。如：</p>
<pre><code>const p = Promise.all([p1, p2, p3]);</code></pre><p>p的状态由p1、p2和p3决定，分成两种情况：<br>1、p1、p2、p3的状态都变成fulfilled，p的状态也变成fulfilled。此时，p1、p2、p3的返回值组成一个数组，传递给p的回调函数<br>2、p1、p2、p3任意一个被rejected，p的状态就变成rejected，此时第一个被reject实例的返回值，传递给p的回调函数</p>
<pre><code>// getJson返回一个promise
const promises = [2,3,5,7,11,13].map(
    id =&gt; return getJson(&#39;/post/&#39; + id + &quot;.json&quot;);
);

Promise.all(promises).then(
    posts =&gt; {}
).catch(
    reason =&gt; {}
);</code></pre><h2 id="race-方法"><a href="#race-方法" class="headerlink" title=".race()方法"></a>.race()方法</h2><p>将多个Promise实例，包装成一个新的Promise实例。只要其中一个Promise实例改变状态，p的状态就随之改变。率先改变的实例的返回值，则传递给p的回调函数</p>
<pre><code>const p = Promise.race([p1, p2, p3]);</code></pre><h2 id="allSettled"><a href="#allSettled" class="headerlink" title=".allSettled()"></a>.allSettled()</h2><p>1、将多个Promise实例，包装成一个新的Promise实例。只有所有实例都返回结果（无论fulfilled or rejected），包装才结束<br>2、返回新的Promise实例，结束只会返回fulfilled<br>3、Promise的监听函数接收到的参数是一个数组，每个成员对应一个传入.allSettled()的Promise实例</p>
<pre><code>const resolved = new Promise.resolve(42);
const rejected = new Promise.reject(-1);

const allSettledPromise = Promise.allSettled([resolved, rejected);
allSettledPromise.then(
    results =&gt; console.log(results);
);

// output:
//      [
//          {status: &#39;fulfilled&#39;, value: 42},
//          {status: &#39;rejected&#39;, reason: -1}
//      ]</code></pre><h2 id="any"><a href="#any" class="headerlink" title=".any()"></a>.any()</h2><p>将多个Promise实例，包装成一个新的Promise实例<br>1、只要参数实例有一个变成fulfilled，新实例就会变成fulfilled<br>2、所有实例都变成rejected状态，新实例就会变成rejected<br>3、.any() 区别与 .race()：不会因为某个Promise变成rejected状态而结束</p>
<h2 id="resolve"><a href="#resolve" class="headerlink" title=".resolve()"></a>.resolve()</h2><p>将现有对象转为Promise对象</p>
<pre><code>const jsPromise = Promise.resolve($.ajax(&#39;/whaerer.json&#39;));</code></pre><pre><code>Promise.resolve(&#39;foo&#39;);
// 等价于
new Promise(
    resolve =&gt; reslovle(&#39;foo&#39;)
);</code></pre><p>Promise.resolve()参数分为四种情况：<br>1、Promise实例：不做修改，直接返回该实例<br>2、thenable对象：将该对象转为Promise对象，然后立即执行thenable对象的then方法</p>
<pre><code>// thenable object
let thenable = {
    then: function(resolve, reject) {
        resolve(42);
    }
};

//
let p1 = Promise.resolve(thenable);
p1.then(
    value =&gt; console.log(value)
)</code></pre><p>上述代码中，thenable对象的then方法执行后，对象p1的状态就变成resolved，从而立即执行最后then方法指定的回调函数 console.log(value)<br>3、非then方法对象 or 非对象：返回一个新的Promise对象，状态为resolved</p>
<pre><code>const p = Promise.resolve(&#39;Hello&#39;);
p.then(
    s =&gt; console.log(s)
);</code></pre><p>字符串’Hello’不属于异步操作，返回Promise的实例状态从一生成就是resolved，故回调函数立即执行<br>4、无参数：返回一个resolved状态的Promise对象（似乎同3一样）</p>
<h2 id="reject"><a href="#reject" class="headerlink" title=".reject()"></a>.reject()</h2><p>Promise.reject(reason)：返回一个新的Promise实例，状态为rejected.<br>.reject()的参数，会原封不动地作为reject的理由，变成后续方法的参数</p>
<pre><code>const p = Promise.reject(&#39;出错&#39;);
// 等同于
const p = new Promise((resolve, reject) =&gt; {
    reject(&#39;出错&#39;)；
})；
p.then(null, s =&gt; console.log(s));</code></pre><h2 id="try"><a href="#try" class="headerlink" title=".try()"></a>.try()</h2><p>场景：不知道or不想区分，函数func是同步or异步，但想用Promise处理，用.then()指定下一步流程，.catch()处理抛出的错误</p>
<pre><code>// [solutioin 1]:
const f = () =&gt; console.log(&#39;now&#39;);
(async () =&gt; f())();
console.log(&#39;next&#39;);

// [solition 2]:
const f = () =&gt; console.log(&#39;now&#39;);
(
    () =&gt; new Promise(
        resolve =&gt; resolve(f())
    )
)();
console.log(&#39;next&#39;);</code></pre></div><div class="post-copyright"><blockquote><p>原文作者: atidat</p><p>原文链接: <a href="https://atidat.github.io/2020/04/04/关于promise/">https://atidat.github.io/2020/04/04/关于promise/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/04/07/%E5%90%8C%E8%8A%B1%E9%A1%BA%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95/" class="pre">同花顺视频面试</a><a href="/2020/04/03/%E5%90%8C%E8%8A%B1%E9%A1%BA%E7%AC%94%E8%AF%95%E9%A2%98/" class="next">同花顺笔试题</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.5"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.5"></script><script>var gitalk = new Gitalk({
  clientID: 'a7fb09fc826b5912fb83',
  clientSecret: '8029536fcb1acf8d9e4d6b06450666f7d449d896',
  repo: '',
  owner: 'atidat## Your GitHub ID, e.g. username',
  admin: [''],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'zh-CN',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#初窥Promise"><span class="toc-text">初窥Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Primose状态"><span class="toc-text">Primose状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise缺点"><span class="toc-text">Promise缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise基本用法"><span class="toc-text">Promise基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个Promise实例"><span class="toc-text">一个Promise实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#then"><span class="toc-text">.then()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深入-then"><span class="toc-text">深入.then()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#catch"><span class="toc-text">.catch()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finally"><span class="toc-text">.finally()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#all"><span class="toc-text">.all()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#race-方法"><span class="toc-text">.race()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#allSettled"><span class="toc-text">.allSettled()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#any"><span class="toc-text">.any()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#resolve"><span class="toc-text">.resolve()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reject"><span class="toc-text">.reject()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try"><span class="toc-text">.try()</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/12/goRPC/gorpc%E4%B9%8B%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88/">goRPC原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/12/%E6%99%93%E4%BF%A1%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95/">晓信视频面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/11/goRPC/gorpc%E4%B9%8B%E5%8E%9F%E7%90%86/">goRPC原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/07/%E5%90%8C%E8%8A%B1%E9%A1%BA%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95/">同花顺视频面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/%E5%85%B3%E4%BA%8Epromise/">关于promise</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/03/%E5%90%8C%E8%8A%B1%E9%A1%BA%E7%AC%94%E8%AF%95%E9%A2%98/">同花顺笔试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/02/%E5%85%B3%E7%88%B1%E5%84%BF%E7%AB%A5%E6%88%90%E9%95%BF/">关爱儿童成长</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/11/Go-1-13%E6%96%B0%E7%89%B9%E6%80%A7/">Go.1.13新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/31/golang%E7%AE%80%E6%98%93%E7%89%88%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/">golang简易版发布订阅</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/27/rip4kobe/">R.I.P For Kobe Bryant</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B/" style="font-size: 15px;">发布订阅模型</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">生活随笔</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">面试</a> <a href="/tags/RPC/" style="font-size: 15px;">RPC</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">11</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">atidat.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>