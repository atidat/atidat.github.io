<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>gorpc之框架搭建client</title>
      <link href="/2020/05/03/goRPC/gorpc%E4%B9%8B%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BAclient/"/>
      <url>/2020/05/03/goRPC/gorpc%E4%B9%8B%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BAclient/</url>
      
        <content type="html"><![CDATA[<h2 id="client结构"><a href="#client结构" class="headerlink" title="client结构"></a><strong>client结构</strong></h2><p>核心能力：</p><ul><li>拼装参数</li><li>发送一个rpc请求</li><li>接收并解析server回包，返回结果给业务层</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 约定所有的client需要实现的通用接口</span></span><br><span class="line"><span class="comment">// 只要业务实现了Client接口，就可无缝替换client组件</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Invoke向下游服务发起调用</span></span><br><span class="line">    Invoke(ctx context.Context, req, rsp <span class="keyword">interface</span>&#123;&#125;, path <span class="keyword">string</span>, opts ...Option) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认Client</span></span><br><span class="line"><span class="keyword">type</span> defaultClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    opts *Options</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选项模式</span></span><br><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">    serviceName <span class="keyword">string</span></span><br><span class="line">    method <span class="keyword">string</span></span><br><span class="line">    target <span class="keyword">string</span></span><br><span class="line">    timeout timeout.Duration</span><br><span class="line">    network <span class="keyword">string</span></span><br><span class="line">    protocol <span class="keyword">string</span></span><br><span class="line">    serializationType <span class="keyword">string</span>    <span class="comment">//e.g. :proto/msgpacka</span></span><br><span class="line">    transportOpts transport.ClientTransportOptions</span><br><span class="line">    interceptors []interceptor.ClientInterceptor</span><br><span class="line">    selectorName <span class="keyword">string</span>         <span class="comment">// service discovery name, e.g. :consul/zookeeper/etcd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*Options)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withServiceName</span><span class="params">(serviceName <span class="keyword">string</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *Options)</span></span> &#123;</span><br><span class="line">        o.servcieName = serviceName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withMethod</span><span class="params">(method <span class="keyword">string</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *Options)</span></span> &#123;</span><br><span class="line">        o.method = method</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建client"><a href="#创建client" class="headerlink" title="创建client"></a><strong>创建client</strong></h2><ol><li>思考：<strong>每次请求时创建client</strong> OR <strong>全局唯一client</strong> ？<ol><li>每次请求创建client<ul><li>优点：请求上下文和参数都是<strong>协程私有</strong>，不会出现安全性问题</li><li>缺点：每次请求创建，会造成对象频繁创建和销毁，性能浪费</li></ul></li><li>全局唯一client<ul><li>优点：不存在因为创建和销毁对象而引起的性能浪费</li><li>缺点：多个协程共用一个client，需要考虑并发安全问题</li></ul></li><li>rpc场景：每秒数万个请求，若每次请求创建一个client，性能劣势太明显</li><li>实现的设计模式：单例模式<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultClient = New()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> New = <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">defaultClient</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;defaultClient&#123;</span><br><span class="line">        opts: &amp;Options&#123;</span><br><span class="line">            protocol: <span class="string">"proto"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="两种调用方式"><a href="#两种调用方式" class="headerlink" title="两种调用方式"></a>两种调用方式</h2><p>server提供服务的两种方式：<strong>反射</strong>、<strong>通过proto文件代码生成</strong><br>client发起下游调用的两种方式：</p><ul><li><p>server通过<em>反射</em>方式时，动态生成service的handler;<br>client则为<em>Invoke</em>方法上层封装一个Call方法暴露给上游调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *defaultClient)</span> <span class="title">Call</span><span class="params">(ctx context.Context, servicePath <span class="keyword">string</span>, req <span class="keyword">interface</span>&#123;&#125;, rsp <span class="keyword">interface</span>&#123;&#125;, opts ...Option)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// reflection calls need to be serialized using msgpack</span></span><br><span class="line">    callOpts := <span class="built_in">make</span>([]Option, <span class="number">0</span>, <span class="built_in">len</span>(opts)+<span class="number">1</span>)</span><br><span class="line">    callOpts = <span class="built_in">append</span>(callOpts, opts...)</span><br><span class="line">    callOpts = <span class="built_in">append</span>(callOpts, WithSerializationType(codec.MsgPack))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// servicePath example: /helloworld.Greeter/SayHello</span></span><br><span class="line">    err := c.Invoke(ctx, req, rsp, servicePath, callOpts ...)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，运用了<em>代理模式</em>思想，Call方法将业务透传的参数和defaultClient选项参数Options拼接，向下游传递   </p></li><li><p>server通过proto文件代码生成，<em>生成service的描述信息</em>；同时，为service的每一个方法生成client调用的stub代码   </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeterClientProxy</span><span class="params">(opts ...client.Option)</span> <span class="title">GreeterClientProxy</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;GreeterClentProxyImpl&#123;client: client.DefaultCleint, opts: opts&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *GreeterClientProxyImpl)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, req *HelloRequest, opts ...client.Option)</span> <span class="params">(*HelloReply, error)</span></span> &#123;</span><br><span class="line">    callOpts := <span class="built_in">make</span>([]client.Option, <span class="number">0</span>, <span class="built_in">len</span>(c.opts)+<span class="built_in">len</span>(opts))</span><br><span class="line">    callOpts = <span class="built_in">append</span>(callOpts， c.opts...)</span><br><span class="line">    callOpts = <span class="built_in">append</span>(callOpts, opts...)</span><br><span class="line"></span><br><span class="line">    rsp := &amp;HelloReply&#123;&#125;</span><br><span class="line">    err := c.client.Invoke(ctx, req, rsp, <span class="string">"/helloworld.Greeter/SayHello"</span>, callOpts...)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, error</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rsp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="invoke函数"><a href="#invoke函数" class="headerlink" title="invoke函数"></a><strong>invoke函数</strong></h2><p>如上所述，业务发起client后端调用，无论通过<em>反射</em>还是<em>代码生成</em>方式，最终都会调用Invoke函数。Invoke完成一个客户端的完整动作。    </p><h3 id="request序列化"><a href="#request序列化" class="headerlink" title="request序列化"></a><strong>request序列化</strong></h3><ol><li>通过客户端透传的序列化类型参数，去获取Serialization对象</li><li>通过Serialization对request序列化成二进制数据 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">serialization := codec.GetSerializtion(c.opts.serializationType)</span><br><span class="line">payLoad, err := serialization.Marshal(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> codec.NerFrameworkError(codes.ClientMsgErrorCode, <span class="string">"request marshal failed..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="对请求体二进制进行打包"><a href="#对请求体二进制进行打包" class="headerlink" title="对请求体二进制进行打包"></a><strong>对请求体二进制进行打包</strong></h3><p>按自定义私有协议格式，拼装协议体，再进行proto序列化成二进制数据   </p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">request</span> := addReqHeader(ctx, payLoad) </span><br><span class="line">reqBuf, <span class="built_in">err</span> := proto.Marshal(<span class="built_in">request</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">err</span> != nil &#123;</span><br><span class="line">    return <span class="built_in">err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用transport向server发送请求，得到server回包"><a href="#调用transport向server发送请求，得到server回包" class="headerlink" title="调用transport向server发送请求，得到server回包"></a><strong>调用transport向server发送请求，得到server回包</strong></h3><p>底层tcp通信能力是通过transport实现。先创建一个client transport，然后调用transport的Send函数向下游发送请求，收到server返回的一个完整响应帧数据   </p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">clientTransport</span> := c.<span class="type">NewClientTransport</span>()</span><br><span class="line"><span class="title">clientTransportOpts</span> := []trans<span class="keyword">port</span>.ClientTransportOption &#123;</span><br><span class="line">    trans<span class="keyword">port</span>.WithServiceName(c.opts.serviceName),</span><br><span class="line">    trans<span class="keyword">port</span>.WithClientTarget(c.opts.target),</span><br><span class="line">    trans<span class="keyword">port</span>.WithClientNetwork(c.opts.network),</span><br><span class="line">    trans<span class="keyword">port</span>.WithClientPool(connpool.GetPool("default"))</span><br><span class="line">    trans<span class="keyword">port</span>.WithSelector(selector.GetSelector(c.opts.selectorName)),</span><br><span class="line">    trans<span class="keyword">port</span>.WithTimeout(c.opts.timeout),</span><br><span class="line">&#125;</span><br><span class="line"><span class="title">frame</span>, err := clientTrans<span class="keyword">port</span>.Send(ctx, reqBody, clientTransportOpts ...)</span><br></pre></td></tr></table></figure><h3 id="对server回包进行解包"><a href="#对server回包进行解包" class="headerlink" title="对server回包进行解包"></a><strong>对server回包进行解包</strong></h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rspBuf, <span class="keyword">err</span> := clientCodec.<span class="keyword">Decode</span>(frame)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parse protocol header</span></span><br><span class="line">response := &amp;protocol.Response&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> = proto.Unmarshal(rspBuf, response); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="response反序列化"><a href="#response反序列化" class="headerlink" title="response反序列化"></a><strong>response反序列化</strong></h3><p>通过调用Serialization对象的Unmarshal方法进行反序列化</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serializtion.<span class="constructor">Unmarsh(<span class="params">response</span>.<span class="params">payLoad</span>, <span class="params">rsp</span>)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>声网电话面试</title>
      <link href="/2020/04/16/%E5%A3%B0%E7%BD%91%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95/"/>
      <url>/2020/04/16/%E5%A3%B0%E7%BD%91%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><ol><li>如何读取零值</li><li>leftjoin、rightjoin、innerjoin区别</li></ol><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><ol><li>常用docker命令</li><li>docker combat 和 consul区别</li></ol><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><ol><li>一个协程占用最小内存空间，4GB内存理论最多可跑多少协程</li><li>一个线程占用最小内存空间，4GB内存理论最多可跑多少线程</li><li>线、协程区别</li></ol><h3 id="web框架"><a href="#web框架" class="headerlink" title="web框架"></a>web框架</h3><p>web框架有哪些？</p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ol><li>cokkie、session</li></ol><h3 id="golang、python语言上的哪些差异导致运行效率巨大"><a href="#golang、python语言上的哪些差异导致运行效率巨大" class="headerlink" title="golang、python语言上的哪些差异导致运行效率巨大"></a>golang、python语言上的哪些差异导致运行效率巨大</h3><h3 id="负载均衡（lvs、etcd）原理"><a href="#负载均衡（lvs、etcd）原理" class="headerlink" title="负载均衡（lvs、etcd）原理"></a>负载均衡（lvs、etcd）原理</h3><h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h3><ol><li>如何定义async函数</li><li>resolve、reject怎么理解</li><li>async/await和Promise联系</li></ol><h3 id="服务间通信"><a href="#服务间通信" class="headerlink" title="服务间通信"></a>服务间通信</h3><ol><li>restful api和grpc api接口区别</li><li>protobuf协议</li><li>grpc协议</li><li>不同开发语言怎么使用grpc</li></ol><h3 id="前、后端如何通信技术栈有哪些"><a href="#前、后端如何通信技术栈有哪些" class="headerlink" title="前、后端如何通信技术栈有哪些"></a>前、后端如何通信技术栈有哪些</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gorpc之框架搭建server</title>
      <link href="/2020/04/13/goRPC/gorpc%E4%B9%8B%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BAserver/"/>
      <url>/2020/04/13/goRPC/gorpc%E4%B9%8B%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BAserver/</url>
      
        <content type="html"><![CDATA[<p><big>注：本文内容购买于掘金小册，仅做于个人学习。若有侵权，谢绝转载</big></p><h2 id="server结构"><a href="#server结构" class="headerlink" title="server结构"></a>server结构</h2><p>server端任务：</p><ul><li>定义服务、发布服务</li><li>根据服务名和请求方法名路由到一个handler处理器</li><li>handler处理请求，将响应返回client</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    opts *ServerOptions</span><br><span class="line">    serviers map[<span class="keyword">string</span>]Service</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServerOptions：通过选项模式，透传业务指定的参数</span></span><br><span class="line"><span class="keyword">type</span> ServerOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    address <span class="keyword">string</span> <span class="comment">// listening address, support ip:port pattern or domain name pattern</span></span><br><span class="line">    network <span class="keyword">string</span> <span class="comment">// network type, e.g.tcp or udp</span></span><br><span class="line">    protocol <span class="keyword">string</span> <span class="comment">// e.g.proto or json</span></span><br><span class="line">    timeout <span class="keyword">time</span><span class="variable">.Duration</span></span><br><span class="line">    serializationType <span class="keyword">string</span> <span class="comment">// default: proto</span></span><br><span class="line"></span><br><span class="line">    selectorSvrAddr <span class="keyword">string</span> <span class="comment">//service discovery server adress, required whern using the third-party service discovery plugin</span></span><br><span class="line">    tracingSvrAddr <span class="keyword">string</span> <span class="comment">//tracing plugin server address, required when using the third-party tracing plugin</span></span><br><span class="line">    tracingSpanName <span class="keyword">string</span> <span class="comment">// tracing span name, required when using the third-party tacing plugin</span></span><br><span class="line">    pluginNames []<span class="keyword">string</span> <span class="comment">// plugin name</span></span><br><span class="line">    interceptors []interceptor<span class="variable">.ServiceInterceptor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service接口定义每个服务需要提供的通用能力</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">    Register(<span class="keyword">string</span>, Handler) <span class="comment">// handler函数注册</span></span><br><span class="line">    Serve(*ServerOptions)</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service接口的具体实现</span></span><br><span class="line"><span class="comment">// 核心是handlers</span></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">    svr <span class="keyword">interface</span>&#123;&#125;             <span class="comment">// server</span></span><br><span class="line">    ctx <span class="keyword">context</span><span class="variable">.Context</span>         <span class="comment">// 每一个service对应一个上下文进行管理</span></span><br><span class="line">    cancel <span class="keyword">context</span><span class="variable">.CancelFunc</span>   <span class="comment">//context的控制器</span></span><br><span class="line">    serviceName <span class="keyword">string</span></span><br><span class="line">    handlers map[<span class="keyword">string</span>]Handler <span class="comment">// 每一类请求分配一个Handler处理</span></span><br><span class="line">    opts *ServerOptions </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="server提供能力"><a href="#server提供能力" class="headerlink" title="server提供能力"></a>server提供能力</h2><h3 id="server创建"><a href="#server创建" class="headerlink" title="server创建"></a>server创建</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(optFuncs ...ServerOption)</span> *<span class="title">Server</span></span> &#123; <span class="comment">// ServerOption这里是函数类型，命名不太友好</span></span><br><span class="line">    s := &amp;Server &#123;</span><br><span class="line">        opts: &amp;ServerOptions&#123;&#125;,</span><br><span class="line">        services: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Service),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, optfunc := <span class="keyword">range</span> optFuncs &#123;</span><br><span class="line">        optfunc(s.opts)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>服务注册：将Service添加到server的service map中   </p><ul><li>通过go struct定义服务。如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"context"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Msg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Msg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, req *HelloRequest)</span> <span class="params">(*HelloReply, error)</span></span> &#123;</span><br><span class="line">    rsp := &amp;HelloReply&#123;</span><br><span class="line">        Msg: <span class="string">"world"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rsp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个服务后，进行服务注册</span></span><br><span class="line">s.RegisterService(<span class="string">"/helloworld.Greeter"</span>, <span class="built_in">new</span>(helloworld.Service))</span><br></pre></td></tr></table></figure></li><li>通过proto文件定义服务</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gorpc之框架概览</title>
      <link href="/2020/04/13/goRPC/gorpc%E4%B9%8B%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88/"/>
      <url>/2020/04/13/goRPC/gorpc%E4%B9%8B%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p><big>注：本文内容购买于掘金小册，仅做于个人学习。若有侵权，谢绝转载</big></p><h2 id="goRPC框架模块及能力"><a href="#goRPC框架模块及能力" class="headerlink" title="goRPC框架模块及能力"></a><big>goRPC框架模块及能力</big></h2><ul><li>client：支持客户端发包</li><li>server：支持服务端发包</li><li>transport：提供底层的通信能力</li><li>codec：支持自定义协议的解析、序列化和反序列化</li><li>pool：支持连接池和对象池等实现，提供客户端连接复用和对象复用</li><li>log：提供日志能力</li><li>selector：提供寻址能力，支持服务发现和负载均衡等默认实现</li><li>stream：提供服务端和客户端上下文数据透传能力</li><li>protocol：支持自定义私有协议</li><li>plugin：支持第三方插件化</li><li>interceptor：提供框架拦截器</li><li>metadata：支持客户端和服务端参数传递</li></ul><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="https://i.loli.net/2020/04/12/OoDP54grtuSClbR.jpg" alt="goRPC整体框架"><br>层次架构：   </p><ol><li>业务层：位于最上层，包括client和server. <ul><li>server：<ul><li>解析收包的请求参数</li><li>回写响应</li></ul></li><li>client：<ul><li>拼装请求参数</li><li>发起invoke调用</li><li>向server端发包</li></ul></li></ul></li><li>组件层：位于中间层，为业务层提供接口调用的通用化能力。包括：<ul><li>interceptor：拦截器组件</li><li>resolver：服务发现组件</li><li>loadbalance：负载均衡组件</li><li>codec：打解包组件</li><li>protocol：协议组件</li><li>log：日志组件</li><li>metadata：上下文参数透传</li></ul></li><li>传输层：实现client和server<ul><li>建立连接</li><li>发送数据</li><li>为请求分配链接</li><li>链接状态管理</li><li>连接关闭</li></ul></li><li>插件层：对接第三方业务系统，实现了基于consul进行服务发现的插件和基于jaeger进行分布式链路追踪的插件</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议：client和server通信间的约定<br>通用协议（如grpc） or 自定义二进制私有协议 ====&gt; 自定义二进制私有协议</p><h3 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h3><p>根据性能对常见的序列化方式排序：<br>gogoprotobuf &gt; msgpack &gt; flatbuffers &gt; thrift &gt; protobuf &gt; json &gt; xml<br>RPC框架支持代码生成和反射两种调用方式。此处，反射选择msgack, 代码生成选择protobuf</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>go周边生态提供服务发现能力的开源组件由consul和etcd，都是基于raft分布式一致性协议，提供k/v存储能力。consul更全面，封装了服务发现、健康检查和内置DNS server等。</p><h2 id="分布式链路追踪"><a href="#分布式链路追踪" class="headerlink" title="分布式链路追踪"></a>分布式链路追踪</h2><ol><li>业界标准：opentracing，约定分布式链路追踪的组件进行<strong>*span上报</strong>的标准格式，为开发语言提供了api支持。</li><li>go的标准参考<a href="https://github.com/opentracing/opentracing-go" target="_blank" rel="noopener">opentarcing-go</a></li><li>业内实现该标准的组件有zipkin和jaeger. jarger由go开发，故选择之</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>晓信视频面试</title>
      <link href="/2020/04/12/%E6%99%93%E4%BF%A1%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95/"/>
      <url>/2020/04/12/%E6%99%93%E4%BF%A1%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<ol><li><p>项目中提到了gorm, 请问下如果让你去设计orm，你会怎么做，你会考虑哪些点？</p><ul><li>没回答上来，之前头条面试也问过一次，没回答上来。现在这里根据网上查到的答案记录下。</li></ul></li><li><p>项目中提到了主备选举，能大概讲一下什么是主备选举嘛？你了解raft协议吗？</p><ul><li>基于 <em>etcd</em> 实现的选举服务提供主备选举的能力。对于分布式服务，进行数据库写的时候，只要一个进程才能完成。此时可以通过主备机的概念，形成 <em>一主多备</em>，由主机去处理业务。容灾时，<em>主机降备</em>，选举服务 <em>重新选举</em>，选出一个新的主，完成容灾切换。（待完善回答）</li><li>未接触过raft协议，似乎不好理解（待完善回答） </li></ul></li><li><p>协程间切换是在内核态完成，线程间切换是在用户态完成。衍生出一个问题，用户态和内核态区别在哪？（待完善回答）</p><ul><li>特权指令的执行权限。cpu根据指令危险程度划分四个级别：RING0、RING1、RING2和RING3。用户态代码只能执行RING3级别的指令，</li><li>提供统一的应用层接口</li></ul></li><li><h2 id="对RPC理解？（看完gorpc小册后再来回答）"><a href="#对RPC理解？（看完gorpc小册后再来回答）" class="headerlink" title="对RPC理解？（看完gorpc小册后再来回答）"></a>对RPC理解？（看完gorpc小册后再来回答）</h2><ul><li></li><li></li></ul></li><li><h2 id="描述下OSI7层协议"><a href="#描述下OSI7层协议" class="headerlink" title="描述下OSI7层协议"></a>描述下OSI7层协议</h2></li><li><p>TCP和UDP区别？你说QQ消息是基于UDP协议，那他是怎么解决丢包问题呢？</p></li><li><p>对微服务的理解？服务发现？</p></li><li><p>对鉴权的理解</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goRPC原理</title>
      <link href="/2020/04/11/goRPC/gorpc%E4%B9%8B%E5%8E%9F%E7%90%86/"/>
      <url>/2020/04/11/goRPC/gorpc%E4%B9%8B%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><big>注：本文内容购买于掘金小册，仅做于个人学习。若有侵权，谢绝转载</big></p><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a><strong>什么是RPC</strong></h2><p>RPC：Remote Procedure Call，即远程过程调用。通过<strong>本地计算机调用另一台远程计算机上的程序，不需要了解底层网络细节</strong>，使得整个过程就像本地调用一样方便。</p><h2 id="RPC调用过程"><a href="#RPC调用过程" class="headerlink" title="RPC调用过程"></a><strong>RPC调用过程</strong></h2><h3 id="复习下本地调用"><a href="#复习下本地调用" class="headerlink" title="复习下本地调用"></a><strong>复习下本地调用</strong></h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>, <span class="keyword">err</span> := os.<span class="keyword">Open</span>(<span class="string">"test.txt"</span>)</span><br><span class="line">b := make([]byte, 1024)</span><br><span class="line"><span class="keyword">file</span>.<span class="keyword">Read</span>(b)</span><br></pre></td></tr></table></figure><h3 id="RPC过程架构"><a href="#RPC过程架构" class="headerlink" title="RPC过程架构"></a><strong>RPC过程架构</strong></h3><p><img src="https://i.loli.net/2020/04/10/LZhtIVKcXwiWFpC.jpg" alt="RPC简单架构.jpg"><br>对于一次RPC调用，单独看客户端或者服务端，会发现和本地调用基本一样；区别，<strong>数据源不在本机而在远程主机</strong>，所以通过网络调用去获取数据。假设把<strong>网络调用的细节封装</strong>，使得其对客户端程序几乎完全无感知。这就是<big><strong>RPC需要解决的本质问题</strong></big></p><h2 id="一次RPC调用涉及的环节"><a href="#一次RPC调用涉及的环节" class="headerlink" title="一次RPC调用涉及的环节"></a><strong>一次RPC调用涉及的环节</strong></h2><p>Socket、协议、寻址、序列化和反序列化、异常处理</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a><strong>Socket</strong></h3><p>socket：计算机间通信的约定或方式</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a><strong>协议</strong></h3><p>协议：tcp、udp、http</p><h3 id="寻址的两个过程"><a href="#寻址的两个过程" class="headerlink" title="寻址的两个过程"></a>寻址的两个过程</h3><ol><li>服务发现：通过域名或者服务名找到服务器的所有IP</li><li>负载均衡：在上述所有IP中，选择一个IP接收、处理客户端请求</li></ol><p><em>我觉的这两点阐述的太不专业了</em></p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><ol><li>序列化：对象类型 –&gt; 二进制流</li><li>反序列化：二进制流 –&gt; 对象类型<br>客户端（序列化） -&gt; &lt;我是网络&gt;二进制流&lt;/我是网络&gt; -&gt; 服务端（反序列化）<br>常用序列化方式：json、protobuf、flattbuffers</li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>当一次RPC出错了，如何判断是在客户端、服务端或中间链路，又或是网络超时和丢包呢？<br>暂不抛出<strong>服务治理</strong>的概念（包含服务发现、负载均衡、限流、熔断、超时、重试和服务追踪）</p><h2 id="RPC需要解决的问题"><a href="#RPC需要解决的问题" class="headerlink" title="RPC需要解决的问题"></a>RPC需要解决的问题</h2><ol><li>开发效率：避免每次RPC进行重复的socket操作、序列话和反序列化、协议解析、寻址处理和异常处理</li><li>通信效率：<ul><li>为了避免每次建立请求都重新创建和销毁，通常采用长连接</li><li>客户端的话，使用连接池进行连接复用</li></ul></li><li>数据传输<ul><li>序列化：需要支持多种序列化方式 &amp;&amp; 支持业务自定义</li><li>传输效率：传输数据包大小和协议（后续章节详述，记得这里标注相应章节号）</li></ul></li><li>通用化：<ul><li>所有组件<strong>可插拔</strong></li><li>所有组件支持<strong>业务自定义</strong></li></ul></li><li>服务治理</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同花顺视频面试</title>
      <link href="/2020/04/07/%E5%90%8C%E8%8A%B1%E9%A1%BA%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95/"/>
      <url>/2020/04/07/%E5%90%8C%E8%8A%B1%E9%A1%BA%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>匆匆记一次同花顺面试经历</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>balabala   </p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>这块目前也没怎么准备，回答的很一般。   </p><h1 id="C语言及项目相关"><a href="#C语言及项目相关" class="headerlink" title="C语言及项目相关"></a>C语言及项目相关</h1><h2 id="遇到的问题：踩内存如何解决"><a href="#遇到的问题：踩内存如何解决" class="headerlink" title="遇到的问题：踩内存如何解决"></a>遇到的问题：踩内存如何解决</h2><p>1、打印日志看内存指向的值和地址<br>2、gdb调试   </p><h2 id="现在这类问题，有什么工具去排查"><a href="#现在这类问题，有什么工具去排查" class="headerlink" title="现在这类问题，有什么工具去排查"></a>现在这类问题，有什么工具去排查</h2><p>没回答上来（只点了下coredump）   </p><h2 id="哪些情况会踩内存（内存泄露）"><a href="#哪些情况会踩内存（内存泄露）" class="headerlink" title="哪些情况会踩内存（内存泄露）"></a>哪些情况会踩内存（内存泄露）</h2><p>1、函数间调用（指针作为参数传递）<br>2、分配区域限制<br>3、其他情况没回答上来   </p><h2 id="上述情况如何避免"><a href="#上述情况如何避免" class="headerlink" title="上述情况如何避免"></a>上述情况如何避免</h2><p>1、通过接口文档或swagger文档去说明<br>2、通过头文件说明   </p><h2 id="C的面向对象的编程思想"><a href="#C的面向对象的编程思想" class="headerlink" title="C的面向对象的编程思想"></a>C的面向对象的编程思想</h2><p>没get到点   </p><h2 id="实习期间嵌入式项目介绍"><a href="#实习期间嵌入式项目介绍" class="headerlink" title="实习期间嵌入式项目介绍"></a>实习期间嵌入式项目介绍</h2><p>balbala   </p><h2 id="模块驱动软件"><a href="#模块驱动软件" class="headerlink" title="模块驱动软件"></a>模块驱动软件</h2><h2 id="串口协议"><a href="#串口协议" class="headerlink" title="串口协议"></a>串口协议</h2><p>忘了，没回答上来   </p><h2 id="串口逻辑"><a href="#串口逻辑" class="headerlink" title="串口逻辑"></a>串口逻辑</h2><p>忘了，没回答上来</p><h1 id="Golang语言及项目相关"><a href="#Golang语言及项目相关" class="headerlink" title="Golang语言及项目相关"></a>Golang语言及项目相关</h1><h2 id="Golang特性"><a href="#Golang特性" class="headerlink" title="Golang特性"></a>Golang特性</h2><p>1、高并发（GMP）<br>    1.1：G：协程；M：系统线程；P：Processor<br>2、“消息通信取代共享内存”<br>    2.1：对通道读取实现协程间通信   </p><h2 id="如何实现定时任务"><a href="#如何实现定时任务" class="headerlink" title="如何实现定时任务"></a>如何实现定时任务</h2><p>1、语言自身有模块可实现<br>2、通过无缓存channel读写实现<br>3、通过加/解锁和全局status对定时任务操作   </p><h2 id="上述话题后续两种，倾向"><a href="#上述话题后续两种，倾向" class="headerlink" title="上述话题后续两种，倾向"></a>上述话题后续两种，倾向</h2><p>倾向无缓存channel。解释了锁和全局status的劣势</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>没回答上来（算法+过程）</p><h2 id="golang内存问题"><a href="#golang内存问题" class="headerlink" title="golang内存问题"></a>golang内存问题</h2><p>pprof，其他没回答上来</p><h2 id="平时生活深入或感兴趣"><a href="#平时生活深入或感兴趣" class="headerlink" title="平时生活深入或感兴趣"></a>平时生活深入或感兴趣</h2><p>分布式，中间件</p><h2 id="如何实现队列"><a href="#如何实现队列" class="headerlink" title="如何实现队列"></a>如何实现队列</h2><p>1、语言自身有模块<br>2、通过两个slice做为队列的基本元素</p><h2 id="项目中go用的什么框架"><a href="#项目中go用的什么框架" class="headerlink" title="项目中go用的什么框架"></a>项目中go用的什么框架</h2><p>微服务框架：go-chassis<br>数据库：gorm<br>这里应该详述   </p><h1 id="在职情况"><a href="#在职情况" class="headerlink" title="在职情况"></a>在职情况</h1><h2 id="离职原因"><a href="#离职原因" class="headerlink" title="离职原因"></a>离职原因</h2><p>这里不详细说了</p><h2 id="职业发展规划（3-5年）"><a href="#职业发展规划（3-5年）" class="headerlink" title="职业发展规划（3~5年）"></a>职业发展规划（3~5年）</h2><p>还是写代码，写到架构师</p><h2 id="项目版本迭代周期"><a href="#项目版本迭代周期" class="headerlink" title="项目版本迭代周期"></a>项目版本迭代周期</h2><p>大版本 one half year，日常版本 2 weeks</p><h2 id="基于上述问题，如何管理项目"><a href="#基于上述问题，如何管理项目" class="headerlink" title="基于上述问题，如何管理项目"></a>基于上述问题，如何管理项目</h2><p>回答地不好，乱说一气</p><h2 id="哪些项目最成功"><a href="#哪些项目最成功" class="headerlink" title="哪些项目最成功"></a>哪些项目最成功</h2><p>balabala，体现了参与度和责任感</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="希望加入什么样地团队"><a href="#希望加入什么样地团队" class="headerlink" title="希望加入什么样地团队"></a>希望加入什么样地团队</h2><p>-。–！又是没想清楚乱回答<br>1、做一些代码开发、需求开发<br>2、团队文化：以开发者的身份去交流经验、业务   </p><h2 id="薪资待遇"><a href="#薪资待遇" class="headerlink" title="薪资待遇"></a>薪资待遇</h2><p>基于当前面试情况和工作情况决定</p><h2 id="有没有想问的"><a href="#有没有想问的" class="headerlink" title="有没有想问的"></a>有没有想问的</h2><p>没有。因为没想好，面试准备不够，该骂，没体现出应有的尊重。   </p><h1 id="杂：扫码登陆描述下过程"><a href="#杂：扫码登陆描述下过程" class="headerlink" title="杂：扫码登陆描述下过程"></a>杂：扫码登陆描述下过程</h1><p>昨天在掘金稍微少了下，没细看。估计面试官也是掘金上看的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于promise</title>
      <link href="/2020/04/04/%E5%85%B3%E4%BA%8Epromise/"/>
      <url>/2020/04/04/%E5%85%B3%E4%BA%8Epromise/</url>
      
        <content type="html"><![CDATA[<p>归档下阮一峰《ECMAScript6》之Promise对象</p><h1 id="初窥Promise"><a href="#初窥Promise" class="headerlink" title="初窥Promise"></a>初窥Promise</h1><p>Promise：<br>抽象层面：可以看作为一个容器，保存着某个未来才会结束的事件（异步操作）<br>代码层面：是一个对象，从它获取异步操作的消息   </p><h2 id="Primose状态"><a href="#Primose状态" class="headerlink" title="Primose状态"></a>Primose状态</h2><p>1、对象的状态不受外界影响。<br>    1.1、Promise对象代表一个异步操作，始终处于以下的某一种状态：pending（进行中）、fulfilled（已成功）、rejected（已失效）<br>    1.2、只有异步操作的结果，才决定当前的状态<br>2、一旦对象状态改变，就不会再变，任何时候都可以得到这个结果。<br>    2.1、以下两种情况才会导致状态改变：pending -&gt; fulfilled 和 pending -&gt; rejected.<br>    2.2、状态凝固了，称为resolved. 此时，再对Promise对象添加回调函数，也会立即得到结果。   </p><h2 id="Promise缺点"><a href="#Promise缺点" class="headerlink" title="Promise缺点"></a>Promise缺点</h2><p>1、无法取消Promise. 新建后立刻执行，无法取消<br>2、若不设置回调函数，Promise内部抛出的函数，不会反馈到外部<br>3、处于pending状态时，无法得知进展到哪一阶段（刚开始 or 结束）</p><h1 id="Promise基本用法"><a href="#Promise基本用法" class="headerlink" title="Promise基本用法"></a>Promise基本用法</h1><h2 id="一个Promise实例"><a href="#一个Promise实例" class="headerlink" title="一个Promise实例"></a>一个Promise实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*异步操作成功*/</span>) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>1、Promise构造函数接收一个函数作为参数，该函数的参数为resolve和reject. resolve和reject时JavaScript提供的函数<br>2、resolve：将Promise对象状态从 pending -&gt; fulfilled. 异步操作成功时调用，将异步操作的结果，作为参数传递出去<br>3、reject：将Promise对象状态从 pending -&gt; rejected. 异步操作失败时调用，将异步操作抛出错误，作为参数传递出去   </p><h2 id="then"><a href="#then" class="headerlink" title=".then()"></a>.then()</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span><span class="params">(error)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>1、生成Promise实例后，用then方法分别指定resolved状态和reject状态的回调函数<br>2、then方法接收两个回调函数作为参数，第二个回调函数可选。第一个回调函数是Promise对象的状态变为resolved调用，第二个回调函数是Promise对象的状态变为rejected时调用。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">reslove, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line">        setTimeout(resolve, ms, <span class="string">'done'</span>)；</span><br><span class="line">    &#125;)；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timetout(<span class="number">100</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述代码，timeout方法返回一个Promise实例，表示一段时间后发生的结果。过了指定时间后，Promise实例状态变为resolved，触发then方法绑定的回调函数</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> promise = new Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>('Promise);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(funciton() &#123;</span><br><span class="line">    console.<span class="built_in">log</span>('resolve.');</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>('Hi');</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">//      Promise</span></span><br><span class="line"><span class="comment">//      Hi</span></span><br><span class="line"><span class="comment">//      resolve.</span></span><br><span class="line"><span class="comment">// 解释：Promise新建后立刻执行，首先输出Promise，而then方法指定的回调函数，将在当前脚本所有同步任务执行完才执行，故"resolve"最后执行</span></span><br></pre></td></tr></table></figure><p>异步加载图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">        image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(image);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'could not load image'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        image.src= url;        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ajax操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJson = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> handle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !=== <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(<span class="keyword">this</span>.response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="comment">// do some client code</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getJson(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Contentes: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'corrupted: '</span>, error)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>1、resolve和reject函数带有参数，那么它们的参数会被传递给回调函数。<br>2、reject参数通常为Error对象的实例<br>3、resolve函数除了为普通值，还可以为一个新的promise。如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resovle, reject</span>) </span>&#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resovle, reject</span>) </span>&#123;</span><br><span class="line">    resolve(p1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时，p1的状态会传递给p2. 即p1的状态决定p2的状态。若p1是pending，则p2也是pending；若p1是resolved or rejected，则p2的回调函数立刻执行。   </p><h2 id="深入-then"><a href="#深入-then" class="headerlink" title="深入.then()"></a>深入.then()</h2><p>1、then方法返回的是一个新的Promise实例，则可以写链式then方法。如：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJson(<span class="string">"./posts.json"</span>).then(<span class="function"><span class="keyword">function</span><span class="params">(json)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span><span class="params">(post)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2、箭指函数写法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJson(<span class="string">"./posts.json"</span>).then(</span><br><span class="line">    post =&gt; getJson(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">    comments =&gt; <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments),</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="catch"><a href="#catch" class="headerlink" title=".catch()"></a>.catch()</h2><p>指定发生错误时的回调函数，是then(null, rejection) or then(undefined, rejection)的别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJson(<span class="string">"./posts.json"</span>).then(</span><br><span class="line">    posts =&gt; <span class="comment">// ...</span></span><br><span class="line">).catch(</span><br><span class="line">    error =&gt; <span class="built_in">console</span>.log(<span class="string">'corrupted error'</span>, error);</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>异步操作抛出错误和then方法抛出错误都会被catch方法捕获   </p><p>前面说过，then方法一般只写resolved状态的函数，rejected状态的函数总在catch方法使用。如：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad code</span></span><br><span class="line">promise.then(</span><br><span class="line">    data =&gt; &#123;&#125;;</span><br><span class="line">    err =&gt; &#123;&#125;;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good code</span></span><br><span class="line">promise.then(</span><br><span class="line">    data =&gt; &#123;&#125;;</span><br><span class="line">).catch(</span><br><span class="line">    err =&gt; &#123;&#125;;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="finally"><a href="#finally" class="headerlink" title=".finally()"></a>.finally()</h2><p>不管Promise对象状态如何，finally方法，保证其内部代码都会执行。<br>.finally()的回调函数不接受任何参数，即不依赖于Promise的执行结果。   </p><h2 id="all"><a href="#all" class="headerlink" title=".all()"></a>.all()</h2><p>.all()将多个Promise实例，包装成一个新的Promise实例。如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">const</span> p = Promise.all([<span class="built_in">p1</span>, <span class="built_in">p2</span>, <span class="built_in">p3</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>p的状态由p1、p2和p3决定，分成两种情况：<br>1、p1、p2、p3的状态都变成fulfilled，p的状态也变成fulfilled。此时，p1、p2、p3的返回值组成一个数组，传递给p的回调函数<br>2、p1、p2、p3任意一个被rejected，p的状态就变成rejected，此时第一个被reject实例的返回值，传递给p的回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getJson返回一个promise</span></span><br><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>].map(</span><br><span class="line">    id =&gt; <span class="keyword">return</span> getJson(<span class="string">'/post/'</span> + id + <span class="string">".json"</span>);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(</span><br><span class="line">    posts =&gt; &#123;&#125;</span><br><span class="line">).catch(</span><br><span class="line">    reason =&gt; &#123;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="race-方法"><a href="#race-方法" class="headerlink" title=".race()方法"></a>.race()方法</h2><p>将多个Promise实例，包装成一个新的Promise实例。只要其中一个Promise实例改变状态，p的状态就随之改变。率先改变的实例的返回值，则传递给p的回调函数</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">const</span> p = Promise.race([<span class="built_in">p1</span>, <span class="built_in">p2</span>, <span class="built_in">p3</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="allSettled"><a href="#allSettled" class="headerlink" title=".allSettled()"></a>.allSettled()</h2><p>1、将多个Promise实例，包装成一个新的Promise实例。只有所有实例都返回结果（无论fulfilled or rejected），包装才结束<br>2、返回新的Promise实例，结束只会返回fulfilled<br>3、Promise的监听函数接收到的参数是一个数组，每个成员对应一个传入.allSettled()的Promise实例</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const resolved = <span class="keyword">new</span> <span class="module-access"><span class="module"><span class="identifier">Promise</span>.</span></span>resolve(<span class="number">42</span>);</span><br><span class="line">const rejected = <span class="keyword">new</span> <span class="module-access"><span class="module"><span class="identifier">Promise</span>.</span></span>reject<span class="number">(-1)</span>;</span><br><span class="line"></span><br><span class="line">const allSettledPromise = <span class="module-access"><span class="module"><span class="identifier">Promise</span>.</span></span>all<span class="constructor">Settled([<span class="params">resolved</span>, <span class="params">rejected</span>)</span>;</span><br><span class="line">allSettledPromise.<span class="keyword">then</span>(</span><br><span class="line">   <span class="function"> <span class="params">results</span> =&gt;</span> console.log(results);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">//      [</span></span><br><span class="line"><span class="comment">//          &#123;status: 'fulfilled', value: 42&#125;,</span></span><br><span class="line"><span class="comment">//          &#123;status: 'rejected', reason: -1&#125;</span></span><br><span class="line"><span class="comment">//      ]</span></span><br></pre></td></tr></table></figure><h2 id="any"><a href="#any" class="headerlink" title=".any()"></a>.any()</h2><p>将多个Promise实例，包装成一个新的Promise实例<br>1、只要参数实例有一个变成fulfilled，新实例就会变成fulfilled<br>2、所有实例都变成rejected状态，新实例就会变成rejected<br>3、.any() 区别与 .race()：不会因为某个Promise变成rejected状态而结束</p><h2 id="resolve"><a href="#resolve" class="headerlink" title=".resolve()"></a>.resolve()</h2><p>将现有对象转为Promise对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/whaerer.json'</span>));</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    resolve =&gt; reslovle(<span class="string">'foo'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Promise.resolve()参数分为四种情况：<br>1、Promise实例：不做修改，直接返回该实例<br>2、thenable对象：将该对象转为Promise对象，然后立即执行thenable对象的then方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thenable object</span></span><br><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(</span><br><span class="line">    value =&gt; <span class="built_in">console</span>.log(value)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上述代码中，thenable对象的then方法执行后，对象p1的状态就变成resolved，从而立即执行最后then方法指定的回调函数 console.log(value)<br>3、非then方法对象 or 非对象：返回一个新的Promise对象，状态为resolved</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line">p.then(</span><br><span class="line">    s =&gt; <span class="built_in">console</span>.log(s)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>字符串’Hello’不属于异步操作，返回Promise的实例状态从一生成就是resolved，故回调函数立即执行<br>4、无参数：返回一个resolved状态的Promise对象（似乎同3一样）</p><h2 id="reject"><a href="#reject" class="headerlink" title=".reject()"></a>.reject()</h2><p>Promise.reject(reason)：返回一个新的Promise实例，状态为rejected.<br>.reject()的参数，会原封不动地作为reject的理由，变成后续方法的参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错'</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'出错'</span>)；</span><br><span class="line">&#125;)；</span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="params">s</span> =&gt;</span> <span class="built_in">console</span>.log(s));</span><br></pre></td></tr></table></figure><h2 id="try"><a href="#try" class="headerlink" title=".try()"></a>.try()</h2><p>场景：不知道or不想区分，函数func是同步or异步，但想用Promise处理，用.then()指定下一步流程，.catch()处理抛出的错误</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [solutioin 1]:</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; f())();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [solition 2]:</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(</span><br><span class="line">    () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">        resolve =&gt; resolve(f())</span><br><span class="line">    )</span><br><span class="line">)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>同花顺笔试题</title>
      <link href="/2020/04/03/%E5%90%8C%E8%8A%B1%E9%A1%BA%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2020/04/03/%E5%90%8C%E8%8A%B1%E9%A1%BA%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>记一次同花顺golang笔试题    </p><h4 id="题目一：读取文件重复行"><a href="#题目一：读取文件重复行" class="headerlink" title="题目一：读取文件重复行"></a>题目一：读取文件重复行</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRepeatedLines</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// file := "D:\\Projects\\leetcode\\example.log"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(file); os.IsNotExist(err) &#123;</span><br><span class="line">fmt.Println(<span class="string">"File Is Not Existed."</span>)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd, err := os.Open(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Open File Failed."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repo := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>, <span class="number">0</span>)</span><br><span class="line">stream := bufio.NewReader(fd)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">line, err := stream.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">// fmt.Print(string(line))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok := repo[<span class="keyword">string</span>(line)]; !ok &#123;</span><br><span class="line">repo[<span class="keyword">string</span>(line)] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">"Read File Ended"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Printf("%v", repo)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目二：slice由哪几个部分构成？如下代码输出为？"><a href="#题目二：slice由哪几个部分构成？如下代码输出为？" class="headerlink" title="题目二：slice由哪几个部分构成？如下代码输出为？"></a>题目二：slice由哪几个部分构成？如下代码输出为？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">fmt.Println(s == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>slice结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    ptr *Elem   <span class="comment">// 指向数组的指针</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span>     <span class="comment">// 切片长度</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span>     <span class="comment">// 切片容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：false<br>解释：s虽然被赋了个空值，但类型其实是个[]int类型，和nil无法比较。</p><h4 id="题目三：反转整数数组的顺序"><a href="#题目三：反转整数数组的顺序" class="headerlink" title="题目三：反转整数数组的顺序"></a>题目三：反转整数数组的顺序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">revert</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        nums[i], nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>-i] = nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>-i], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目四：协程和线程的区别"><a href="#题目四：协程和线程的区别" class="headerlink" title="题目四：协程和线程的区别"></a>题目四：协程和线程的区别</h4><p>1、协程由线程调度管理<br>2、协程间切换由用户态代码实现，线程间切换由内核态切换实现<br>3、协程内存占用少   </p><h4 id="题目五：想要并发输出0-9，以下代码是否存在问题，应该如何改进呢？"><a href="#题目五：想要并发输出0-9，以下代码是否存在问题，应该如何改进呢？" class="headerlink" title="题目五：想要并发输出0-9，以下代码是否存在问题，应该如何改进呢？"></a>题目五：想要并发输出0-9，以下代码是否存在问题，应该如何改进呢？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[solution <span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"current: "</span>, i)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[solution <span class="number">2</span>]</span><br><span class="line"><span class="comment">// 解法有问题，未能输出10个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">i := &lt;-ch</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;(ch)</span><br><span class="line"></span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目六：分享下项目中goroutine泄露的排查经历-or-手写一段goroutine泄露代码"><a href="#题目六：分享下项目中goroutine泄露的排查经历-or-手写一段goroutine泄露代码" class="headerlink" title="题目六：分享下项目中goroutine泄露的排查经历 or 手写一段goroutine泄露代码"></a>题目六：分享下项目中goroutine泄露的排查经历 or 手写一段goroutine泄露代码</h4><h4 id="题目七：修改以下代码，实现并发安全的cache机制，如果可以实现重复抑制（同一资源只有一个goroutine请求）可加分（不需要考虑cache更新问题和LRU）"><a href="#题目七：修改以下代码，实现并发安全的cache机制，如果可以实现重复抑制（同一资源只有一个goroutine请求）可加分（不需要考虑cache更新问题和LRU）" class="headerlink" title="题目七：修改以下代码，实现并发安全的cache机制，如果可以实现重复抑制（同一资源只有一个goroutine请求）可加分（不需要考虑cache更新问题和LRU）"></a>题目七：修改以下代码，实现并发安全的cache机制，如果可以实现重复抑制（同一资源只有一个goroutine请求）可加分（不需要考虑cache更新问题和LRU）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        r.ParseForm()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(r.Form[<span class="string">"url"</span>]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            body, _ := fetch(r.Fomr[<span class="string">"url"</span>][<span class="number">0</span>])</span><br><span class="line">            w.Writer(body)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Close()</span><br><span class="line">    <span class="keyword">return</span> ioutil.ReadAll(resp.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关爱儿童成长</title>
      <link href="/2020/03/02/%E5%85%B3%E7%88%B1%E5%84%BF%E7%AB%A5%E6%88%90%E9%95%BF/"/>
      <url>/2020/03/02/%E5%85%B3%E7%88%B1%E5%84%BF%E7%AB%A5%E6%88%90%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2020/03/01/32abAe.jpg" alt="小委托人"></p><h1 id="《小委托人》"><a href="#《小委托人》" class="headerlink" title="《小委托人》"></a>《小委托人》</h1><h2 id><a href="#" class="headerlink" title></a></h2><p>本着消磨时间的打算，看了这部早早下载却一直在手机里吃灰的《小委托人》，很难受。我想，影片中暴露在我眼前的这些罪行，也许只是冰山下的一角。法律所统计到的受伤害的孩子，也许还有不少在忍受煎熬。  </p><h2 id="愤怒"><a href="#愤怒" class="headerlink" title="愤怒"></a>愤怒</h2><p> 对于感性的我，看到这些施虐的画面时，心中涌起愤怒。明明这些应当在阳光下肆意欢笑的孩子，为什么却胆怯地缩在阴暗地房间一角，瑟瑟发抖。当“娃娃鱼”用锤子砸开那一家的房门时，面对着施虐完的继母，我都在屏幕前挥舞着我的拳头。</p><h2 id="无助"><a href="#无助" class="headerlink" title="无助"></a>无助</h2><p>然而，面对着影片结束后的字幕，“但绝大多数施暴者都被判以缓期执行或罚款”，我陷入了迷惘，被一种无力感包围。若是对这些施暴者的罪恶行为加以重刑，那么孩子的抚养该怎么办？倘若爷爷奶奶辈无能力或无意愿抚养，难道指望现有的社会福利去收养如此之多的受害儿童？</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>个人观点：应当对这些证据确凿的施虐父母，处以重刑，并在刑满释放后，加以类似电子镣铐之类的器件，标签化这些“施虐”者的罪犯。<br>个人困惑：如何处理孩子的抚养问题？若是仅仅对“施虐者”判期缓刑或罚款，我相信这绝不是处罚，而是纵容这些罪恶行为。</p><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>斗胆提出以下几点，不知是否合理。<br>1）杜绝根因：对现有法律施虐儿童的章节，重新review，不合适处重新拟制，并通过微信、头条等社交媒体，广而告之这点。<br>2）加强对儿童福利机构的人员考核。对于这类机构，绝不允许“关系户”和“养老户”上岗。并对有把握的受害家庭，儿童机构人员有权利要求警力人员配合调查案件。<br>3）对于定罪的犯案人员，处以重刑，并在刑满释放后，在3~5年内标签化这类人员，剥夺其儿童抚养权。</p><h2 id="附注："><a href="#附注：" class="headerlink" title="附注："></a>附注：</h2><p>其他诸如培训关爱儿童志愿者的想法，还不成熟，暂且不叙。  </p><p>注：影片中旁人的冷漠和精英阶层对底层人民视作“蚂蚁的”观点，此处暂不展开，后续有感再详述。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go.1.13新特性</title>
      <link href="/2020/02/11/Go-1-13%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2020/02/11/Go-1-13%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>《goproxy.cn - 为中国 Go 语言开发者量身打造的模块代理》整理<br><a href="https://segmentfault.com/a/1190000020293616?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020293616?utm_source=tag-newest</a></p><h1 id="Go-1-13-新特性说明"><a href="#Go-1-13-新特性说明" class="headerlink" title="Go 1.13 新特性说明"></a><strong>Go 1.13 新特性说明</strong></h1><h2 id="一、关于Module"><a href="#一、关于Module" class="headerlink" title="一、关于Module"></a><strong>一、关于Module</strong></h2><h3 id="1、前情提要"><a href="#1、前情提要" class="headerlink" title="1、前情提要"></a><strong>1、前情提要</strong></h3><p>Go Modules最早发布于1.11版本。随着一起发布的还有Module proxy protocol 协议，通过该协议可以搭建Go模块代理，最后交由GOPROXY环境变量，指引go命令后续在抓取模块时的途径。</p><h3 id="2、GOPROXY"><a href="#2、GOPROXY" class="headerlink" title="2、GOPROXY"></a><strong>2、GOPROXY</strong></h3><p>1.13版本将GOPROXY默认为<a href="https://proxy.golang.org" target="_blank" rel="noopener">https://proxy.golang.org</a><br>(大陆不可访问)故中国开发者需要修改GORROXY后再开发。七牛云提供了一个Go模块代理：goproxy.cn</p><h3 id="3、使用goproxy-cn"><a href="#3、使用goproxy-cn" class="headerlink" title="3、使用goproxy.cn"></a><strong>3、使用goproxy.cn</strong></h3><p>命令：go env -w GOPROXY=<a href="https://goproxy.cn,direct" target="_blank" rel="noopener">https://goproxy.cn,direct</a><br>direct：解决访问私有库问题。当go抓取目标模块404时，就回退到direct，即目标模块的源头，去抓取</p><h3 id="4、私有库访问"><a href="#4、私有库访问" class="headerlink" title="4、私有库访问"></a><strong>4、私有库访问</strong></h3><p>关于GOPROXY中的direct字段，并不是一个完美的私有库访问问题的解决方案。<br>GONOPROXY环境变量，通过设置该变量可以控制哪些module path能忽略GOPROXY，无脑回源。<br>如：GONOPROXY=*.corp.example.com 意味着go在抓取所有corp.example.com的三级子域名下的所有模块时都将忽略GOPROXY设置，而直接回源到目标模块的源地址</p><h3 id="5、GOSUMDB"><a href="#5、GOSUMDB" class="headerlink" title="5、GOSUMDB"></a><strong>5、GOSUMDB</strong></h3><p>功能：防止从公共模块代理中抓取的模块被篡改<br>默认值：sum.golang.org<br>原理：go将在抓取完所有模块时，对所有模块进行哈希校验，只有校验值和数据库中现有值一致时，才算抓取成功。<br>GONOSUMDB：控制go应该忽略校验哪些module path下的模块</p><h3 id="GOPRIVATE"><a href="#GOPRIVATE" class="headerlink" title="GOPRIVATE"></a><strong>GOPRIVATE</strong></h3><p>简单地理解为设置该变量，即同时设置了GONOPROXY和GONOSUMDB</p><h2 id="二、关于defer"><a href="#二、关于defer" class="headerlink" title="二、关于defer"></a><strong>二、关于defer</strong></h2><p>待续</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang简易版发布订阅</title>
      <link href="/2020/01/31/golang%E7%AE%80%E6%98%93%E7%89%88%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
      <url>/2020/01/31/golang%E7%AE%80%E6%98%93%E7%89%88%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
      
        <content type="html"><![CDATA[<h1 id="golang简易版发布订阅模型"><a href="#golang简易版发布订阅模型" class="headerlink" title="golang简易版发布订阅模型"></a>golang简易版发布订阅模型</h1><p>转载自《Go语言高级编程》  </p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pubsub</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">subscriber <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;         <span class="comment">// 订阅者为一个管道</span></span><br><span class="line">topicFunc  <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span> //主题为一个过滤器</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者对象</span></span><br><span class="line"><span class="keyword">type</span> Publisher <span class="keyword">struct</span> &#123;</span><br><span class="line">m           sync.RWMutex</span><br><span class="line">buffer      <span class="keyword">int</span></span><br><span class="line">timeout     time.Duration</span><br><span class="line">subscribers <span class="keyword">map</span>[subscriber]topicFunc <span class="comment">// 订阅者对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅一个发布者对象，可设置发布超时时间和缓存队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPublisher</span><span class="params">(publishTimeout time.Duration, buffer <span class="keyword">int</span>)</span> *<span class="title">Publisher</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Publisher&#123;</span><br><span class="line">buffer:      buffer,</span><br><span class="line">timeout:     publishTimeout,</span><br><span class="line">subscribers: <span class="built_in">make</span>(<span class="keyword">map</span>[subscriber]topicFunc),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个新的订阅者，订阅全部主题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">Subscribe</span><span class="params">()</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> p.SubscribeTopic(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个新的订阅者，订阅过滤器筛选后的主题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">SubscribeTopic</span><span class="params">(topic topicFunc)</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, p.buffer)</span><br><span class="line">p.m.Lock()</span><br><span class="line">p.subscribers[ch] = topic</span><br><span class="line">p.m.Unlock()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出订阅</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">Evict</span><span class="params">(sub <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">p.m.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"><span class="built_in">delete</span>(p.subscribers, sub)</span><br><span class="line"><span class="built_in">close</span>(sub)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布一个主题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">Publish</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">p.m.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> sub, topic := <span class="keyword">range</span> p.subscribers &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> p.sendTopic(sub, topic, v, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭发布者对象，同时关闭所有的订阅者管道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.m.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sub := <span class="keyword">range</span> p.subscribers &#123;</span><br><span class="line"><span class="built_in">delete</span>(p.subscribers, sub)</span><br><span class="line"><span class="built_in">close</span>(sub)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送主题，可以容忍一定的超时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">sendTopic</span><span class="params">(sub subscriber, topic topicFunc, v <span class="keyword">interface</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">if</span> topic != <span class="literal">nil</span> &amp;&amp; !topic(v) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> sub &lt;- v:</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(p.timeout):</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"pubsub"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := pubsub.NewPublisher(<span class="number">100</span>*time.Millsecond, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">defer</span> p.<span class="built_in">close</span>()</span><br><span class="line"></span><br><span class="line">all := p.Subscribe()</span><br><span class="line">golang := p.Subscribe(<span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s, ok := v.(<span class="keyword">string</span>); ok &#123; <span class="comment">// x.(T) 类型断言</span></span><br><span class="line"><span class="keyword">return</span> strings.Contains(s, <span class="string">"golang"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.Publish(<span class="string">"hello world!"</span>)</span><br><span class="line">p.Publish(<span class="string">"hello golang!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> msg := <span class="keyword">range</span> all &#123;</span><br><span class="line">fmt.Println(<span class="string">"all:"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> msg := <span class="keyword">range</span> golang &#123;</span><br><span class="line">fmt.Println(<span class="string">"golang:"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 发布订阅模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R.I.P For Kobe Bryant</title>
      <link href="/2020/01/27/rip4kobe/"/>
      <url>/2020/01/27/rip4kobe/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/01/27/gdYVhI4rDMRUzKj.jpg" alt="youngkobe.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>闲聊记事（一）</title>
      <link href="/2020/01/27/%E9%97%B2%E8%81%8A%E8%AE%B0%E4%BA%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/01/27/%E9%97%B2%E8%81%8A%E8%AE%B0%E4%BA%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="关于新型冠状病毒"><a href="#关于新型冠状病毒" class="headerlink" title="关于新型冠状病毒"></a>关于新型冠状病毒</h2><p>截至到现在（1月26日 23：31），丁香网实时统计的全国确诊人数已达2076例。从前，这些数字，我往往无感，总觉得太遥远。如今，这些数字却化为了恐惧，如同羊水般包裹在周围。   </p><p>我一直以为自己不怕死，看来还是高估了自己。现在才发现，如果人都是突然间死亡的，那么怕是没有人会恐惧死亡。最令人害怕的，还是死亡逼近的过程，亦或是拖拉着镰刀而来的死神，一步步靠近。这种感觉，真tn的刺激。   </p><p>今日凌晨刷虎扑，不时看到几个放出口罩链接的帖子，每每点击进去一看，都是售罄。明日还是去劳保市场看看是否有口罩卖吧。   </p><h2 id="关于春节"><a href="#关于春节" class="headerlink" title="关于春节"></a>关于春节</h2><p>现在还是庚子年元月初二，晚上也草草地回到了杭州。回到房间后，从没聊过天的室友们，一个都没回来，也是哦，这个点都是在家里。寻摸着一个便利店买了一大瓶水后，便又回了房间。   </p><p>今年，哦不，去年的大年三十，对即将来到的新的一年完全没有期盼，因此也没有许愿的念头。偶尔的祝福短信，也礼貌而简洁地回复了。   </p><p>至于为什么会这样，我想是2019年过的并不如意。年初、年中，工作上各种波折、失意；年末，生活上又遭遇打击。想了想，现在也算是心态好。安于现状，但也试图改变。   </p><p>好在，我也完全不记得前年许下的愿望，所以就让失意的2019失忆下去吧。生活的琐事总是不记得这也是我为数不多的优点了。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>摸鱼摸到初三凌晨了，略有睡意。ipad上的爱情公寓5这一集也快放完了，那就洗洗睡吧。    </p><p><img src="https://i.loli.net/2020/01/27/rKYtTXmngJkUpa8.jpg" alt="晚安.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
