<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>晓信视频面试</title>
      <link href="/2020/04/12/%E6%99%93%E4%BF%A1%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95/"/>
      <url>/2020/04/12/%E6%99%93%E4%BF%A1%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<ol><li><p>项目中提到了gorm, 请问下如果让你去设计orm，你会怎么做，你会考虑哪些点？</p><ul><li>没回答上来，之前头条面试也问过一次，没回答上来。现在这里根据网上查到的答案记录下。</li></ul></li><li><p>项目中提到了主备选举，能大概讲一下什么是主备选举嘛？你了解raft协议吗？</p><ul><li>基于 <em>etcd</em> 实现的选举服务提供主备选举的能力。对于分布式服务，进行数据库写的时候，只要一个进程才能完成。此时可以通过主备机的概念，形成 <em>一主多备</em>，由主机去处理业务。容灾时，<em>主机降备</em>，选举服务 <em>重新选举</em>，选出一个新的主，完成容灾切换。（待完善回答）</li><li>未接触过raft协议，似乎不好理解（待完善回答） </li></ul></li><li><p>协程间切换是在内核态完成，线程间切换是在用户态完成。衍生出一个问题，用户态和内核态区别在哪？（待完善回答）</p><ul><li>特权指令的执行权限。cpu根据指令危险程度划分四个级别：RING0、RING1、RING2和RING3。用户态代码只能执行RING3级别的指令，</li><li>提供统一的应用层接口</li></ul></li><li><h2 id="对RPC理解？（看完gorpc小册后再来回答）"><a href="#对RPC理解？（看完gorpc小册后再来回答）" class="headerlink" title="对RPC理解？（看完gorpc小册后再来回答）"></a>对RPC理解？（看完gorpc小册后再来回答）</h2><ul><li></li><li></li></ul></li><li><h2 id="描述下OSI7层协议"><a href="#描述下OSI7层协议" class="headerlink" title="描述下OSI7层协议"></a>描述下OSI7层协议</h2></li><li><p>TCP和UDP区别？你说QQ消息是基于UDP协议，那他是怎么解决丢包问题呢？</p></li><li><p>对微服务的理解？服务发现？</p></li><li><p>对鉴权的理解</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同花顺视频面试</title>
      <link href="/2020/04/07/%E5%90%8C%E8%8A%B1%E9%A1%BA%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95/"/>
      <url>/2020/04/07/%E5%90%8C%E8%8A%B1%E9%A1%BA%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>匆匆记一次同花顺面试经历</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>balabala   </p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>这块目前也没怎么准备，回答的很一般。   </p><h1 id="C语言及项目相关"><a href="#C语言及项目相关" class="headerlink" title="C语言及项目相关"></a>C语言及项目相关</h1><h2 id="遇到的问题：踩内存如何解决"><a href="#遇到的问题：踩内存如何解决" class="headerlink" title="遇到的问题：踩内存如何解决"></a>遇到的问题：踩内存如何解决</h2><p>1、打印日志看内存指向的值和地址<br>2、gdb调试   </p><h2 id="现在这类问题，有什么工具去排查"><a href="#现在这类问题，有什么工具去排查" class="headerlink" title="现在这类问题，有什么工具去排查"></a>现在这类问题，有什么工具去排查</h2><p>没回答上来（只点了下coredump）   </p><h2 id="哪些情况会踩内存（内存泄露）"><a href="#哪些情况会踩内存（内存泄露）" class="headerlink" title="哪些情况会踩内存（内存泄露）"></a>哪些情况会踩内存（内存泄露）</h2><p>1、函数间调用（指针作为参数传递）<br>2、分配区域限制<br>3、其他情况没回答上来   </p><h2 id="上述情况如何避免"><a href="#上述情况如何避免" class="headerlink" title="上述情况如何避免"></a>上述情况如何避免</h2><p>1、通过接口文档或swagger文档去说明<br>2、通过头文件说明   </p><h2 id="C的面向对象的编程思想"><a href="#C的面向对象的编程思想" class="headerlink" title="C的面向对象的编程思想"></a>C的面向对象的编程思想</h2><p>没get到点   </p><h2 id="实习期间嵌入式项目介绍"><a href="#实习期间嵌入式项目介绍" class="headerlink" title="实习期间嵌入式项目介绍"></a>实习期间嵌入式项目介绍</h2><p>balbala   </p><h2 id="模块驱动软件"><a href="#模块驱动软件" class="headerlink" title="模块驱动软件"></a>模块驱动软件</h2><h2 id="串口协议"><a href="#串口协议" class="headerlink" title="串口协议"></a>串口协议</h2><p>忘了，没回答上来   </p><h2 id="串口逻辑"><a href="#串口逻辑" class="headerlink" title="串口逻辑"></a>串口逻辑</h2><p>忘了，没回答上来</p><h1 id="Golang语言及项目相关"><a href="#Golang语言及项目相关" class="headerlink" title="Golang语言及项目相关"></a>Golang语言及项目相关</h1><h2 id="Golang特性"><a href="#Golang特性" class="headerlink" title="Golang特性"></a>Golang特性</h2><p>1、高并发（GMP）<br>    1.1：G：协程；M：系统线程；P：Processor<br>2、“消息通信取代共享内存”<br>    2.1：对通道读取实现协程间通信   </p><h2 id="如何实现定时任务"><a href="#如何实现定时任务" class="headerlink" title="如何实现定时任务"></a>如何实现定时任务</h2><p>1、语言自身有模块可实现<br>2、通过无缓存channel读写实现<br>3、通过加/解锁和全局status对定时任务操作   </p><h2 id="上述话题后续两种，倾向"><a href="#上述话题后续两种，倾向" class="headerlink" title="上述话题后续两种，倾向"></a>上述话题后续两种，倾向</h2><p>倾向无缓存channel。解释了锁和全局status的劣势</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>没回答上来（算法+过程）</p><h2 id="golang内存问题"><a href="#golang内存问题" class="headerlink" title="golang内存问题"></a>golang内存问题</h2><p>pprof，其他没回答上来</p><h2 id="平时生活深入或感兴趣"><a href="#平时生活深入或感兴趣" class="headerlink" title="平时生活深入或感兴趣"></a>平时生活深入或感兴趣</h2><p>分布式，中间件</p><h2 id="如何实现队列"><a href="#如何实现队列" class="headerlink" title="如何实现队列"></a>如何实现队列</h2><p>1、语言自身有模块<br>2、通过两个slice做为队列的基本元素</p><h2 id="项目中go用的什么框架"><a href="#项目中go用的什么框架" class="headerlink" title="项目中go用的什么框架"></a>项目中go用的什么框架</h2><p>微服务框架：go-chassis<br>数据库：gorm<br>这里应该详述   </p><h1 id="在职情况"><a href="#在职情况" class="headerlink" title="在职情况"></a>在职情况</h1><h2 id="离职原因"><a href="#离职原因" class="headerlink" title="离职原因"></a>离职原因</h2><p>这里不详细说了</p><h2 id="职业发展规划（3-5年）"><a href="#职业发展规划（3-5年）" class="headerlink" title="职业发展规划（3~5年）"></a>职业发展规划（3~5年）</h2><p>还是写代码，写到架构师</p><h2 id="项目版本迭代周期"><a href="#项目版本迭代周期" class="headerlink" title="项目版本迭代周期"></a>项目版本迭代周期</h2><p>大版本 one half year，日常版本 2 weeks</p><h2 id="基于上述问题，如何管理项目"><a href="#基于上述问题，如何管理项目" class="headerlink" title="基于上述问题，如何管理项目"></a>基于上述问题，如何管理项目</h2><p>回答地不好，乱说一气</p><h2 id="哪些项目最成功"><a href="#哪些项目最成功" class="headerlink" title="哪些项目最成功"></a>哪些项目最成功</h2><p>balabala，体现了参与度和责任感</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="希望加入什么样地团队"><a href="#希望加入什么样地团队" class="headerlink" title="希望加入什么样地团队"></a>希望加入什么样地团队</h2><p>-。–！又是没想清楚乱回答<br>1、做一些代码开发、需求开发<br>2、团队文化：以开发者的身份去交流经验、业务   </p><h2 id="薪资待遇"><a href="#薪资待遇" class="headerlink" title="薪资待遇"></a>薪资待遇</h2><p>基于当前面试情况和工作情况决定</p><h2 id="有没有想问的"><a href="#有没有想问的" class="headerlink" title="有没有想问的"></a>有没有想问的</h2><p>没有。因为没想好，面试准备不够，该骂，没体现出应有的尊重。   </p><h1 id="杂：扫码登陆描述下过程"><a href="#杂：扫码登陆描述下过程" class="headerlink" title="杂：扫码登陆描述下过程"></a>杂：扫码登陆描述下过程</h1><p>昨天在掘金稍微少了下，没细看。估计面试官也是掘金上看的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于promise</title>
      <link href="/2020/04/04/%E5%85%B3%E4%BA%8Epromise/"/>
      <url>/2020/04/04/%E5%85%B3%E4%BA%8Epromise/</url>
      
        <content type="html"><![CDATA[<p>归档下阮一峰《ECMAScript6》之Promise对象</p><h1 id="初窥Promise"><a href="#初窥Promise" class="headerlink" title="初窥Promise"></a>初窥Promise</h1><p>Promise：<br>抽象层面：可以看作为一个容器，保存着某个未来才会结束的事件（异步操作）<br>代码层面：是一个对象，从它获取异步操作的消息   </p><h2 id="Primose状态"><a href="#Primose状态" class="headerlink" title="Primose状态"></a>Primose状态</h2><p>1、对象的状态不受外界影响。<br>    1.1、Promise对象代表一个异步操作，始终处于以下的某一种状态：pending（进行中）、fulfilled（已成功）、rejected（已失效）<br>    1.2、只有异步操作的结果，才决定当前的状态<br>2、一旦对象状态改变，就不会再变，任何时候都可以得到这个结果。<br>    2.1、以下两种情况才会导致状态改变：pending -&gt; fulfilled 和 pending -&gt; rejected.<br>    2.2、状态凝固了，称为resolved. 此时，再对Promise对象添加回调函数，也会立即得到结果。   </p><h2 id="Promise缺点"><a href="#Promise缺点" class="headerlink" title="Promise缺点"></a>Promise缺点</h2><p>1、无法取消Promise. 新建后立刻执行，无法取消<br>2、若不设置回调函数，Promise内部抛出的函数，不会反馈到外部<br>3、处于pending状态时，无法得知进展到哪一阶段（刚开始 or 结束）</p><h1 id="Promise基本用法"><a href="#Promise基本用法" class="headerlink" title="Promise基本用法"></a>Promise基本用法</h1><h2 id="一个Promise实例"><a href="#一个Promise实例" class="headerlink" title="一个Promise实例"></a>一个Promise实例</h2><pre><code>const promise = new Promise(function(resolve, reject) {    // business code    if(/*异步操作成功*/) {        resolve(value);    } else{        reject(error);    }})</code></pre><p>1、Promise构造函数接收一个函数作为参数，该函数的参数为resolve和reject. resolve和reject时JavaScript提供的函数<br>2、resolve：将Promise对象状态从 pending -&gt; fulfilled. 异步操作成功时调用，将异步操作的结果，作为参数传递出去<br>3、reject：将Promise对象状态从 pending -&gt; rejected. 异步操作失败时调用，将异步操作抛出错误，作为参数传递出去   </p><h2 id="then"><a href="#then" class="headerlink" title=".then()"></a>.then()</h2><pre><code>promise.then(function(value) {    // success}, function(error) {    // failure})</code></pre><p>1、生成Promise实例后，用then方法分别指定resolved状态和reject状态的回调函数<br>2、then方法接收两个回调函数作为参数，第二个回调函数可选。第一个回调函数是Promise对象的状态变为resolved调用，第二个回调函数是Promise对象的状态变为rejected时调用。   </p><pre><code>function timeout(ms) {    return new Promise(function(reslove, reject) {        console.log(&#39;Promise&#39;);        setTimeout(resolve, ms, &#39;done&#39;)；    })；}timetout(100).then((value) =&gt; {    console.log(value);})</code></pre><p>上述代码，timeout方法返回一个Promise实例，表示一段时间后发生的结果。过了指定时间后，Promise实例状态变为resolved，触发then方法绑定的回调函数</p><pre><code>let promise = new Promise(function(resolve, reject) {    console.log(&#39;Promise);    resolve();});promise.then(funciton() {    console.log(&#39;resolve.&#39;);});console.log(&#39;Hi&#39;);// output://      Promise//      Hi//      resolve.// 解释：Promise新建后立刻执行，首先输出Promise，而then方法指定的回调函数，将在当前脚本所有同步任务执行完才执行，故&quot;resolve&quot;最后执行</code></pre><p>异步加载图片</p><pre><code>function loadImageAsync(url) {    return new Promise(function(resolve, reject) {        const image = new Image();        image.onload = function() {            resolve(image);        }        image.onerror = function() {            reject(new Error(&#39;could not load image&#39;));        }        image.src= url;            });}</code></pre><p>Ajax操作</p><pre><code>const getJson = function(url) {    const promise = new Promise(function(resolve, reject) {        const handle = function() {            if (this.readyState !=== 4) {                return;            }            if (this.status === 200) {                resolve(this.response);            } else {                reject(new Error(this.statusText));            }        };        const client = new XMLHttpRequest();        // do some client code    });    return promise;}getJson(&quot;/posts.json&quot;).then(function(json) {    console.log(&#39;Contentes: &#39; + json);}, function(error) {    console.error(&#39;corrupted: &#39;, error)});</code></pre><p>1、resolve和reject函数带有参数，那么它们的参数会被传递给回调函数。<br>2、reject参数通常为Error对象的实例<br>3、resolve函数除了为普通值，还可以为一个新的promise。如</p><pre><code>const p1 = new Promise(function(resovle, reject) {});const p2 = new Promise(function(resovle, reject) {    resolve(p1);});</code></pre><p>此时，p1的状态会传递给p2. 即p1的状态决定p2的状态。若p1是pending，则p2也是pending；若p1是resolved or rejected，则p2的回调函数立刻执行。   </p><h2 id="深入-then"><a href="#深入-then" class="headerlink" title="深入.then()"></a>深入.then()</h2><p>1、then方法返回的是一个新的Promise实例，则可以写链式then方法。如：</p><pre><code>getJson(&quot;./posts.json&quot;).then(function(json) {    return json.post;}).then(function(post) {    // ...});</code></pre><p>2、箭指函数写法</p><pre><code>getJson(&quot;./posts.json&quot;).then(    post =&gt; getJson(post.commentURL)).then(    comments =&gt; console.log(&quot;resolved: &quot;, comments),    err =&gt; console.log(&quot;rejected: &quot;, err));</code></pre><h2 id="catch"><a href="#catch" class="headerlink" title=".catch()"></a>.catch()</h2><p>指定发生错误时的回调函数，是then(null, rejection) or then(undefined, rejection)的别名。</p><pre><code>getJson(&quot;./posts.json&quot;).then(    posts =&gt; // ...).catch(    error =&gt; console.log(&#39;corrupted error&#39;, error););</code></pre><p>异步操作抛出错误和then方法抛出错误都会被catch方法捕获   </p><p>前面说过，then方法一般只写resolved状态的函数，rejected状态的函数总在catch方法使用。如：</p><pre><code>// bad codepromise.then(    data =&gt; {};    err =&gt; {};);// good codepromise.then(    data =&gt; {};).catch(    err =&gt; {};);</code></pre><h2 id="finally"><a href="#finally" class="headerlink" title=".finally()"></a>.finally()</h2><p>不管Promise对象状态如何，finally方法，保证其内部代码都会执行。<br>.finally()的回调函数不接受任何参数，即不依赖于Promise的执行结果。   </p><h2 id="all"><a href="#all" class="headerlink" title=".all()"></a>.all()</h2><p>.all()将多个Promise实例，包装成一个新的Promise实例。如：</p><pre><code>const p = Promise.all([p1, p2, p3]);</code></pre><p>p的状态由p1、p2和p3决定，分成两种情况：<br>1、p1、p2、p3的状态都变成fulfilled，p的状态也变成fulfilled。此时，p1、p2、p3的返回值组成一个数组，传递给p的回调函数<br>2、p1、p2、p3任意一个被rejected，p的状态就变成rejected，此时第一个被reject实例的返回值，传递给p的回调函数</p><pre><code>// getJson返回一个promiseconst promises = [2,3,5,7,11,13].map(    id =&gt; return getJson(&#39;/post/&#39; + id + &quot;.json&quot;););Promise.all(promises).then(    posts =&gt; {}).catch(    reason =&gt; {});</code></pre><h2 id="race-方法"><a href="#race-方法" class="headerlink" title=".race()方法"></a>.race()方法</h2><p>将多个Promise实例，包装成一个新的Promise实例。只要其中一个Promise实例改变状态，p的状态就随之改变。率先改变的实例的返回值，则传递给p的回调函数</p><pre><code>const p = Promise.race([p1, p2, p3]);</code></pre><h2 id="allSettled"><a href="#allSettled" class="headerlink" title=".allSettled()"></a>.allSettled()</h2><p>1、将多个Promise实例，包装成一个新的Promise实例。只有所有实例都返回结果（无论fulfilled or rejected），包装才结束<br>2、返回新的Promise实例，结束只会返回fulfilled<br>3、Promise的监听函数接收到的参数是一个数组，每个成员对应一个传入.allSettled()的Promise实例</p><pre><code>const resolved = new Promise.resolve(42);const rejected = new Promise.reject(-1);const allSettledPromise = Promise.allSettled([resolved, rejected);allSettledPromise.then(    results =&gt; console.log(results););// output://      [//          {status: &#39;fulfilled&#39;, value: 42},//          {status: &#39;rejected&#39;, reason: -1}//      ]</code></pre><h2 id="any"><a href="#any" class="headerlink" title=".any()"></a>.any()</h2><p>将多个Promise实例，包装成一个新的Promise实例<br>1、只要参数实例有一个变成fulfilled，新实例就会变成fulfilled<br>2、所有实例都变成rejected状态，新实例就会变成rejected<br>3、.any() 区别与 .race()：不会因为某个Promise变成rejected状态而结束</p><h2 id="resolve"><a href="#resolve" class="headerlink" title=".resolve()"></a>.resolve()</h2><p>将现有对象转为Promise对象</p><pre><code>const jsPromise = Promise.resolve($.ajax(&#39;/whaerer.json&#39;));</code></pre><pre><code>Promise.resolve(&#39;foo&#39;);// 等价于new Promise(    resolve =&gt; reslovle(&#39;foo&#39;));</code></pre><p>Promise.resolve()参数分为四种情况：<br>1、Promise实例：不做修改，直接返回该实例<br>2、thenable对象：将该对象转为Promise对象，然后立即执行thenable对象的then方法</p><pre><code>// thenable objectlet thenable = {    then: function(resolve, reject) {        resolve(42);    }};//let p1 = Promise.resolve(thenable);p1.then(    value =&gt; console.log(value))</code></pre><p>上述代码中，thenable对象的then方法执行后，对象p1的状态就变成resolved，从而立即执行最后then方法指定的回调函数 console.log(value)<br>3、非then方法对象 or 非对象：返回一个新的Promise对象，状态为resolved</p><pre><code>const p = Promise.resolve(&#39;Hello&#39;);p.then(    s =&gt; console.log(s));</code></pre><p>字符串’Hello’不属于异步操作，返回Promise的实例状态从一生成就是resolved，故回调函数立即执行<br>4、无参数：返回一个resolved状态的Promise对象（似乎同3一样）</p><h2 id="reject"><a href="#reject" class="headerlink" title=".reject()"></a>.reject()</h2><p>Promise.reject(reason)：返回一个新的Promise实例，状态为rejected.<br>.reject()的参数，会原封不动地作为reject的理由，变成后续方法的参数</p><pre><code>const p = Promise.reject(&#39;出错&#39;);// 等同于const p = new Promise((resolve, reject) =&gt; {    reject(&#39;出错&#39;)；})；p.then(null, s =&gt; console.log(s));</code></pre><h2 id="try"><a href="#try" class="headerlink" title=".try()"></a>.try()</h2><p>场景：不知道or不想区分，函数func是同步or异步，但想用Promise处理，用.then()指定下一步流程，.catch()处理抛出的错误</p><pre><code>// [solutioin 1]:const f = () =&gt; console.log(&#39;now&#39;);(async () =&gt; f())();console.log(&#39;next&#39;);// [solition 2]:const f = () =&gt; console.log(&#39;now&#39;);(    () =&gt; new Promise(        resolve =&gt; resolve(f())    ))();console.log(&#39;next&#39;);</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>同花顺笔试题</title>
      <link href="/2020/04/03/%E5%90%8C%E8%8A%B1%E9%A1%BA%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2020/04/03/%E5%90%8C%E8%8A%B1%E9%A1%BA%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>记一次同花顺golang笔试题    </p><h4 id="题目一：读取文件重复行"><a href="#题目一：读取文件重复行" class="headerlink" title="题目一：读取文件重复行"></a>题目一：读取文件重复行</h4><pre><code>import (    &quot;os&quot;    &quot;bufio&quot;)func getRepeatedLines(file string) map[string]bool {    // file := &quot;D:\\Projects\\leetcode\\example.log&quot;    if _, err := os.Stat(file); os.IsNotExist(err) {        fmt.Println(&quot;File Is Not Existed.&quot;)        return     }    fd, err := os.Open(file)    if err != nil {        fmt.Println(&quot;Open File Failed.&quot;)        return    }    repo := make(map[string]bool, 0)    stream := bufio.NewReader(fd)    for {        line, err := stream.ReadBytes(&#39;\n&#39;)        // fmt.Print(string(line))        if _, ok := repo[string(line)]; !ok {            repo[string(line)] = true        }        if err == io.EOF {            fmt.Println(&quot;Read File Ended&quot;)            break        }    }    // fmt.Printf(&quot;%v&quot;, repo)}</code></pre><h4 id="题目二：slice由哪几个部分构成？如下代码输出为？"><a href="#题目二：slice由哪几个部分构成？如下代码输出为？" class="headerlink" title="题目二：slice由哪几个部分构成？如下代码输出为？"></a>题目二：slice由哪几个部分构成？如下代码输出为？</h4><pre><code>s := []int{}fmt.Println(s == nil)</code></pre><p>slice结构体：</p><pre><code>type slice struct {    ptr *Elem   // 指向数组的指针    len int     // 切片长度    cap int     // 切片容量}</code></pre><p>输出：false<br>解释：s虽然被赋了个空值，但类型其实是个[]int类型，和nil无法比较。</p><h4 id="题目三：反转整数数组的顺序"><a href="#题目三：反转整数数组的顺序" class="headerlink" title="题目三：反转整数数组的顺序"></a>题目三：反转整数数组的顺序</h4><pre><code>func revert(nums []int) []int {    if len(nums) == 0 {        return nums    }    for i := 0; i &lt; len(nums)/2; i++ {        nums[i], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[i]    }    return nums}</code></pre><h4 id="题目四：协程和线程的区别"><a href="#题目四：协程和线程的区别" class="headerlink" title="题目四：协程和线程的区别"></a>题目四：协程和线程的区别</h4><p>1、协程由线程调度管理<br>2、协程间切换由用户态代码实现，线程间切换由内核态切换实现<br>3、协程内存占用少   </p><h4 id="题目五：想要并发输出0-9，以下代码是否存在问题，应该如何改进呢？"><a href="#题目五：想要并发输出0-9，以下代码是否存在问题，应该如何改进呢？" class="headerlink" title="题目五：想要并发输出0-9，以下代码是否存在问题，应该如何改进呢？"></a>题目五：想要并发输出0-9，以下代码是否存在问题，应该如何改进呢？</h4><pre><code>package mainimport &quot;fmt&quot;func main() {    for i := 0; i &lt; 10; i++ {        go func() {            fmt.Println(i)        }()    }}</code></pre><pre><code>[solution 1]func main() {    wg := sync.WaitGroup{}    wg.Add(10)    for i := 0; i &lt; 10; i++         go func(i int) {            fmt.Println(&quot;current: &quot;, i)            wg.Done()        }(i)    }    wg.Wait()}</code></pre><pre><code>[solution 2]// 解法有问题，未能输出10个数func main() {    ch := make(chan int, 0)    for i := 0; i &lt; 10; i++ {        go func(ch &lt;-chan int) {            i := &lt;-ch            fmt.Println(i)            &lt;-ch        }(ch)        ch &lt;- i    }    close(ch)}</code></pre><h4 id="题目六：分享下项目中goroutine泄露的排查经历-or-手写一段goroutine泄露代码"><a href="#题目六：分享下项目中goroutine泄露的排查经历-or-手写一段goroutine泄露代码" class="headerlink" title="题目六：分享下项目中goroutine泄露的排查经历 or 手写一段goroutine泄露代码"></a>题目六：分享下项目中goroutine泄露的排查经历 or 手写一段goroutine泄露代码</h4><h4 id="题目七：修改以下代码，实现并发安全的cache机制，如果可以实现重复抑制（同一资源只有一个goroutine请求）可加分（不需要考虑cache更新问题和LRU）"><a href="#题目七：修改以下代码，实现并发安全的cache机制，如果可以实现重复抑制（同一资源只有一个goroutine请求）可加分（不需要考虑cache更新问题和LRU）" class="headerlink" title="题目七：修改以下代码，实现并发安全的cache机制，如果可以实现重复抑制（同一资源只有一个goroutine请求）可加分（不需要考虑cache更新问题和LRU）"></a>题目七：修改以下代码，实现并发安全的cache机制，如果可以实现重复抑制（同一资源只有一个goroutine请求）可加分（不需要考虑cache更新问题和LRU）</h4><pre><code>package mainimport (    &quot;io/ioutil&quot;    &quot;net/http&quot;)func main() {    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {        r.ParseForm()        if len(r.Form[&quot;url&quot;]) &gt; 0 {            body, _ := fetch(r.Fomr[&quot;url&quot;][0])            w.Writer(body)        }    })    http.ListenAndServe(&quot;:8000&quot;, nil)}func fetch(url string) ([]byte, error) {    resp, err := http.Get(url)    if err != nil {        return nil, err    }    defer resp.Close()    return ioutil.ReadAll(resp.body)}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关爱儿童成长</title>
      <link href="/2020/03/02/%E5%85%B3%E7%88%B1%E5%84%BF%E7%AB%A5%E6%88%90%E9%95%BF/"/>
      <url>/2020/03/02/%E5%85%B3%E7%88%B1%E5%84%BF%E7%AB%A5%E6%88%90%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2020/03/01/32abAe.jpg" alt="小委托人"></p><h1 id="《小委托人》"><a href="#《小委托人》" class="headerlink" title="《小委托人》"></a>《小委托人》</h1><h2 id><a href="#" class="headerlink" title></a></h2><p>本着消磨时间的打算，看了这部早早下载却一直在手机里吃灰的《小委托人》，很难受。我想，影片中暴露在我眼前的这些罪行，也许只是冰山下的一角。法律所统计到的受伤害的孩子，也许还有不少在忍受煎熬。  </p><h2 id="愤怒"><a href="#愤怒" class="headerlink" title="愤怒"></a>愤怒</h2><p> 对于感性的我，看到这些施虐的画面时，心中涌起愤怒。明明这些应当在阳光下肆意欢笑的孩子，为什么却胆怯地缩在阴暗地房间一角，瑟瑟发抖。当“娃娃鱼”用锤子砸开那一家的房门时，面对着施虐完的继母，我都在屏幕前挥舞着我的拳头。</p><h2 id="无助"><a href="#无助" class="headerlink" title="无助"></a>无助</h2><p>然而，面对着影片结束后的字幕，“但绝大多数施暴者都被判以缓期执行或罚款”，我陷入了迷惘，被一种无力感包围。若是对这些施暴者的罪恶行为加以重刑，那么孩子的抚养该怎么办？倘若爷爷奶奶辈无能力或无意愿抚养，难道指望现有的社会福利去收养如此之多的受害儿童？</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>个人观点：应当对这些证据确凿的施虐父母，处以重刑，并在刑满释放后，加以类似电子镣铐之类的器件，标签化这些“施虐”者的罪犯。<br>个人困惑：如何处理孩子的抚养问题？若是仅仅对“施虐者”判期缓刑或罚款，我相信这绝不是处罚，而是纵容这些罪恶行为。</p><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>斗胆提出以下几点，不知是否合理。<br>1）杜绝根因：对现有法律施虐儿童的章节，重新review，不合适处重新拟制，并通过微信、头条等社交媒体，广而告之这点。<br>2）加强对儿童福利机构的人员考核。对于这类机构，绝不允许“关系户”和“养老户”上岗。并对有把握的受害家庭，儿童机构人员有权利要求警力人员配合调查案件。<br>3）对于定罪的犯案人员，处以重刑，并在刑满释放后，在3~5年内标签化这类人员，剥夺其儿童抚养权。</p><h2 id="附注："><a href="#附注：" class="headerlink" title="附注："></a>附注：</h2><p>其他诸如培训关爱儿童志愿者的想法，还不成熟，暂且不叙。  </p><p>注：影片中旁人的冷漠和精英阶层对底层人民视作“蚂蚁的”观点，此处暂不展开，后续有感再详述。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go.1.13新特性</title>
      <link href="/2020/02/11/Go-1-13%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2020/02/11/Go-1-13%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>《goproxy.cn - 为中国 Go 语言开发者量身打造的模块代理》整理<br><a href="https://segmentfault.com/a/1190000020293616?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020293616?utm_source=tag-newest</a></p><h1 id="Go-1-13-新特性说明"><a href="#Go-1-13-新特性说明" class="headerlink" title="Go 1.13 新特性说明"></a><strong>Go 1.13 新特性说明</strong></h1><h2 id="一、关于Module"><a href="#一、关于Module" class="headerlink" title="一、关于Module"></a><strong>一、关于Module</strong></h2><h3 id="1、前情提要"><a href="#1、前情提要" class="headerlink" title="1、前情提要"></a><strong>1、前情提要</strong></h3><p>Go Modules最早发布于1.11版本。随着一起发布的还有Module proxy protocol 协议，通过该协议可以搭建Go模块代理，最后交由GOPROXY环境变量，指引go命令后续在抓取模块时的途径。</p><h3 id="2、GOPROXY"><a href="#2、GOPROXY" class="headerlink" title="2、GOPROXY"></a><strong>2、GOPROXY</strong></h3><p>1.13版本将GOPROXY默认为<a href="https://proxy.golang.org" target="_blank" rel="noopener">https://proxy.golang.org</a><br>(大陆不可访问)故中国开发者需要修改GORROXY后再开发。七牛云提供了一个Go模块代理：goproxy.cn</p><h3 id="3、使用goproxy-cn"><a href="#3、使用goproxy-cn" class="headerlink" title="3、使用goproxy.cn"></a><strong>3、使用goproxy.cn</strong></h3><p>命令：go env -w GOPROXY=<a href="https://goproxy.cn,direct" target="_blank" rel="noopener">https://goproxy.cn,direct</a><br>direct：解决访问私有库问题。当go抓取目标模块404时，就回退到direct，即目标模块的源头，去抓取</p><h3 id="4、私有库访问"><a href="#4、私有库访问" class="headerlink" title="4、私有库访问"></a><strong>4、私有库访问</strong></h3><p>关于GOPROXY中的direct字段，并不是一个完美的私有库访问问题的解决方案。<br>GONOPROXY环境变量，通过设置该变量可以控制哪些module path能忽略GOPROXY，无脑回源。<br>如：GONOPROXY=*.corp.example.com 意味着go在抓取所有corp.example.com的三级子域名下的所有模块时都将忽略GOPROXY设置，而直接回源到目标模块的源地址</p><h3 id="5、GOSUMDB"><a href="#5、GOSUMDB" class="headerlink" title="5、GOSUMDB"></a><strong>5、GOSUMDB</strong></h3><p>功能：防止从公共模块代理中抓取的模块被篡改<br>默认值：sum.golang.org<br>原理：go将在抓取完所有模块时，对所有模块进行哈希校验，只有校验值和数据库中现有值一致时，才算抓取成功。<br>GONOSUMDB：控制go应该忽略校验哪些module path下的模块</p><h3 id="GOPRIVATE"><a href="#GOPRIVATE" class="headerlink" title="GOPRIVATE"></a><strong>GOPRIVATE</strong></h3><p>简单地理解为设置该变量，即同时设置了GONOPROXY和GONOSUMDB</p><h2 id="二、关于defer"><a href="#二、关于defer" class="headerlink" title="二、关于defer"></a><strong>二、关于defer</strong></h2><p>待续</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang简易版发布订阅</title>
      <link href="/2020/01/31/golang%E7%AE%80%E6%98%93%E7%89%88%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
      <url>/2020/01/31/golang%E7%AE%80%E6%98%93%E7%89%88%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
      
        <content type="html"><![CDATA[<h1 id="golang简易版发布订阅模型"><a href="#golang简易版发布订阅模型" class="headerlink" title="golang简易版发布订阅模型"></a>golang简易版发布订阅模型</h1><p>转载自《Go语言高级编程》  </p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><pre class="line-numbers language-golang"><code class="language-golang">package pubsubimport (    "sync"    "time")type (    subscriber chan interface{}         // 订阅者为一个管道    topicFunc  func(v interface{}) bool //主题为一个过滤器)// 发布者对象type Publisher struct {    m           sync.RWMutex    buffer      int    timeout     time.Duration    subscribers map[subscriber]topicFunc // 订阅者对象}// 订阅一个发布者对象，可设置发布超时时间和缓存队列的长度func NewPublisher(publishTimeout time.Duration, buffer int) *Publisher {    return &Publisher{        buffer:      buffer,        timeout:     publishTimeout,        subscribers: make(map[subscriber]topicFunc),    }}// 添加一个新的订阅者，订阅全部主题func (p *Publisher) Subscribe() chan interface{} {    return p.SubscribeTopic(nil)}// 添加一个新的订阅者，订阅过滤器筛选后的主题func (p *Publisher) SubscribeTopic(topic topicFunc) chan interface{} {    ch := make(chan interface{}, p.buffer)    p.m.Lock()    p.subscribers[ch] = topic    p.m.Unlock()    return ch}// 退出订阅func (p *Publisher) Evict(sub chan interface{}) {    p.m.Lock()    defer p.m.Unlock()    delete(p.subscribers, sub)    close(sub)}// 发布一个主题func (p *Publisher) Publish(v interface{}) {    p.m.Lock()    defer p.m.Unlock()    var wg sync.WaitGroup    for sub, topic := range p.subscribers {        wg.Add(1)        go p.sendTopic(sub, topic, v, &wg)    }    wg.Wait()}// 关闭发布者对象，同时关闭所有的订阅者管道func (p *Publisher) Close() {    p.m.Lock()    defer p.m.Unlock()    for sub := range p.subscribers {        delete(p.subscribers, sub)        close(sub)    }}// 发送主题，可以容忍一定的超时func (p *Publisher) sendTopic(sub subscriber, topic topicFunc, v interface{}, wg *sync.WaitGroup) {    defer wg.Done()    if topic != nil && !topic(v) {        return    }    select {    case sub <- v:    case <-time.After(p.timeout):    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><pre class="line-numbers language-golang"><code class="language-golang">import "pubsub"func main() {    p := pubsub.NewPublisher(100*time.Millsecond, 10)    defer p.close()    all := p.Subscribe()    golang := p.Subscribe(func(v interface{}) bool {        if s, ok := v.(string); ok { // x.(T) 类型断言            return strings.Contains(s, "golang")        }        return false    })    p.Publish("hello world!")    p.Publish("hello golang!")    go func() {        for msg := range all {            fmt.Println("all:", msg)        }    } ()    go func() {        for msg := range golang {            fmt.Println("golang:", msg)        }    } ()    time.Sleep(3*time.Second)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 发布订阅模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R.I.P For Kobe Bryant</title>
      <link href="/2020/01/27/rip4kobe/"/>
      <url>/2020/01/27/rip4kobe/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/01/27/gdYVhI4rDMRUzKj.jpg" alt="youngkobe.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>闲聊记事（一）</title>
      <link href="/2020/01/27/%E9%97%B2%E8%81%8A%E8%AE%B0%E4%BA%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/01/27/%E9%97%B2%E8%81%8A%E8%AE%B0%E4%BA%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="关于新型冠状病毒"><a href="#关于新型冠状病毒" class="headerlink" title="关于新型冠状病毒"></a>关于新型冠状病毒</h2><p>截至到现在（1月26日 23：31），丁香网实时统计的全国确诊人数已达2076例。从前，这些数字，我往往无感，总觉得太遥远。如今，这些数字却化为了恐惧，如同羊水般包裹在周围。   </p><p>我一直以为自己不怕死，看来还是高估了自己。现在才发现，如果人都是突然间死亡的，那么怕是没有人会恐惧死亡。最令人害怕的，还是死亡逼近的过程，亦或是拖拉着镰刀而来的死神，一步步靠近。这种感觉，真tn的刺激。   </p><p>今日凌晨刷虎扑，不时看到几个放出口罩链接的帖子，每每点击进去一看，都是售罄。明日还是去劳保市场看看是否有口罩卖吧。   </p><h2 id="关于春节"><a href="#关于春节" class="headerlink" title="关于春节"></a>关于春节</h2><p>现在还是庚子年元月初二，晚上也草草地回到了杭州。回到房间后，从没聊过天的室友们，一个都没回来，也是哦，这个点都是在家里。寻摸着一个便利店买了一大瓶水后，便又回了房间。   </p><p>今年，哦不，去年的大年三十，对即将来到的新的一年完全没有期盼，因此也没有许愿的念头。偶尔的祝福短信，也礼貌而简洁地回复了。   </p><p>至于为什么会这样，我想是2019年过的并不如意。年初、年中，工作上各种波折、失意；年末，生活上又遭遇打击。想了想，现在也算是心态好。安于现状，但也试图改变。   </p><p>好在，我也完全不记得前年许下的愿望，所以就让失意的2019失忆下去吧。生活的琐事总是不记得这也是我为数不多的优点了。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>摸鱼摸到初三凌晨了，略有睡意。ipad上的爱情公寓5这一集也快放完了，那就洗洗睡吧。    </p><p><img src="https://i.loli.net/2020/01/27/rKYtTXmngJkUpa8.jpg" alt="晚安.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goRPC原理</title>
      <link href="/2020/01/27/goRPC/gorpc%E4%B9%8B%E5%8E%9F%E7%90%86/"/>
      <url>/2020/01/27/goRPC/gorpc%E4%B9%8B%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a><strong>什么是RPC</strong></h2><p>RPC：Remote Procedure Call，即远程过程调用。通过<strong>本地计算机调用另一台远程计算机上的程序，不需要了解底层网络细节</strong>，使得整个过程就像本地调用一样方便。</p><h2 id="RPC调用过程"><a href="#RPC调用过程" class="headerlink" title="RPC调用过程"></a><strong>RPC调用过程</strong></h2><h3 id="复习下本地调用"><a href="#复习下本地调用" class="headerlink" title="复习下本地调用"></a><strong>复习下本地调用</strong></h3><pre><code>file, err := os.Open(&quot;test.txt&quot;)b := make([]byte, 1024)file.Read(b)</code></pre><h3 id="RPC过程架构"><a href="#RPC过程架构" class="headerlink" title="RPC过程架构"></a><strong>RPC过程架构</strong></h3><p><img src="https://i.loli.net/2020/04/10/LZhtIVKcXwiWFpC.jpg" alt="RPC简单架构.jpg"><br>对于一次RPC调用，单独看客户端或者服务端，会发现和本地调用基本一样；区别，<strong>数据源不在本机而在远程主机</strong>，所以通过网络调用去获取数据。假设把<strong>网络调用的细节封装</strong>，使得其对客户端程序几乎完全无感知。这就是<big><strong>RPC需要解决的本质问题</strong></big></p><h2 id="一次RPC调用涉及的环节"><a href="#一次RPC调用涉及的环节" class="headerlink" title="一次RPC调用涉及的环节"></a><strong>一次RPC调用涉及的环节</strong></h2><p>Socket、协议、寻址、序列化和反序列化、异常处理</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a><strong>Socket</strong></h3><p>socket：计算机间通信的约定或方式</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a><strong>协议</strong></h3><p>协议：tcp、udp、http</p><h3 id="寻址的两个过程"><a href="#寻址的两个过程" class="headerlink" title="寻址的两个过程"></a>寻址的两个过程</h3><ol><li>服务发现：通过域名或者服务名找到服务器的所有IP</li><li>负载均衡：在上述所有IP中，选择一个IP接收、处理客户端请求</li></ol><p><em>我觉的这两点阐述的太不专业了</em></p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><ol><li>序列化：对象类型 –&gt; 二进制流</li><li>反序列化：二进制流 –&gt; 对象类型<br>客户端（序列化） -&gt; &lt;我是网络&gt;二进制流&lt;/我是网络&gt; -&gt; 服务端（反序列化）<br>常用序列化方式：json、protobuf、flattbuffers</li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>当一次RPC出错了，如何判断是在客户端、服务端或中间链路，又或是网络超时和丢包呢？<br>暂不抛出<strong>服务治理</strong>的概念（包含服务发现、负载均衡、限流、熔断、超时、重试和服务追踪）</p><h2 id="RPC需要解决的问题"><a href="#RPC需要解决的问题" class="headerlink" title="RPC需要解决的问题"></a>RPC需要解决的问题</h2><ol><li>开发效率：避免每次RPC进行重复的socket操作、序列话和反序列化、协议解析、寻址处理和异常处理</li><li>通信效率：<ul><li>为了避免每次建立请求都重新创建和销毁，通常采用长连接</li><li>客户端的话，使用连接池进行连接复用</li></ul></li><li>数据传输<ul><li>序列化：需要支持多种序列化方式 &amp;&amp; 支持业务自定义</li><li>传输效率：传输数据包大小和协议（后续章节详述，记得这里标注相应章节号）</li></ul></li><li>通用化：<ul><li>所有组件<strong>可插拔</strong></li><li>所有组件支持<strong>业务自定义</strong></li></ul></li><li>服务治理</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
